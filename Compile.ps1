param (
    [switch]$Debug,
    [switch]$Run,
    [string]$Arguments
)

if ((Get-Item ".\wdca.ps1" -ErrorAction SilentlyContinue).IsReadOnly) {
    Remove-Item ".\wdca.ps1" -Force
}

$OFS = "`r`n"
$scriptname = "wdca.ps1"
$workingdir = $PSScriptRoot

Push-Location
Set-Location $workingdir

# Variable to sync between runspaces
$sync = [Hashtable]::Synchronized(@{})
$sync.PSScriptRoot = $workingdir
$sync.configs = @{}

function Update-Progress {
    param (
        [Parameter(Mandatory, position=0)]
        [string]$StatusMessage,

        [Parameter(Mandatory, position=1)]
        [ValidateRange(0,100)]
        [int]$Percent,

        [Parameter(position=2)]
        [string]$Activity = "Compiling WDCA"
    )

    Write-Progress -Activity $Activity -Status $StatusMessage -PercentComplete $Percent
}

$header = @"
################################################################################################################
###                                                                                                          ###
### WARNING: This file is automatically generated DO NOT modify this file directly as it will be overwritten ###
###          Windows Deployment & Configuration Assistant (WDCA)                                           ###
###          Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')                                                                                         ###
###                                                                                                          ###
################################################################################################################
"@

Update-Progress "Pre-req: Running Preprocessor..." 0

# Dot source the 'Invoke-Preprocessing' Function from 'tools/Invoke-Preprocessing.ps1' Script
$preprocessingFilePath = ".\tools\Invoke-Preprocessing.ps1"
if (Test-Path $preprocessingFilePath) {
    . $preprocessingFilePath
    
    $excludedFiles = @('.\.git\', '.\.gitignore', '.\.gitattributes', '.\.github\CODEOWNERS', '.\LICENSE', "$preprocessingFilePath", '*.png', '*.exe', '.\.preprocessor_hashes.json')
    $msg = "Pre-req: Code Formatting"
    
    try {
        Invoke-Preprocessing -WorkingDir "$workingdir" -ExcludedFiles $excludedFiles -ProgressStatusMessage $msg
    }
    catch {
        Write-Warning "Preprocessing failed: $($_.Exception.Message)"
    }
}

# Create the script in memory with better error handling
Update-Progress "Pre-req: Allocating Memory" 5
$script_content = [System.Collections.Generic.List[string]]::new()

Update-Progress "Adding: Header" 10
$script_content.Add($header)

Update-Progress "Adding: Version and Start Script" 15
$startScriptPath = "scripts\start.ps1"
if (Test-Path $startScriptPath) {
    $startContent = Get-Content $startScriptPath -Raw -ErrorAction SilentlyContinue
    if ($startContent) {
        $script_content.Add($startContent.replace('#{replaceme}', "$(Get-Date -Format yy.MM.dd)"))
        Write-Host "Added: $startScriptPath" -ForegroundColor Green
    }
} else {
    Write-Warning "Start script not found: $startScriptPath"
}

Update-Progress "Adding: Functions" 25

# Add private functions first
$privateFunctionsPath = "functions\private"
if (Test-Path $privateFunctionsPath) {
    Get-ChildItem $privateFunctionsPath -Recurse -File -Filter "*.ps1" | Sort-Object Name | ForEach-Object {
        try {
            $functionContent = Get-Content $_.FullName -Raw -ErrorAction Stop
            if (-not [string]::IsNullOrWhiteSpace($functionContent)) {
                $script_content.Add($functionContent)
                Write-Host "Added private function: $($_.Name)" -ForegroundColor Cyan
            }
        }
        catch {
            Write-Warning "Failed to read private function $($_.Name): $($_.Exception.Message)"
        }
    }
}

# Add public functions
$publicFunctionsPath = "functions\public"
if (Test-Path $publicFunctionsPath) {
    Get-ChildItem $publicFunctionsPath -Recurse -File -Filter "*.ps1" | Sort-Object Name | ForEach-Object {
        try {
            $functionContent = Get-Content $_.FullName -Raw -ErrorAction Stop
            if (-not [string]::IsNullOrWhiteSpace($functionContent)) {
                $script_content.Add($functionContent)
                Write-Host "Added public function: $($_.Name)" -ForegroundColor Green
            }
        }
        catch {
            Write-Warning "Failed to read public function $($_.Name): $($_.Exception.Message)"
        }
    }
}

Update-Progress "Adding: Config *.json" 50
$configPath = "config"
if (Test-Path $configPath) {
    Get-ChildItem $configPath -Filter "*.json" | ForEach-Object {
        try {
            $json = Get-Content $_.FullName -Raw -ErrorAction Stop
            if (-not [string]::IsNullOrWhiteSpace($json)) {
                $jsonAsObject = $json | ConvertFrom-Json
                
                # Add 'WPFInstall' as a prefix to every entry-name in 'applications.json' file
                if ($_.Name -eq "applications.json") {
                    $newObject = New-Object PSObject
                    foreach ($property in $jsonAsObject.PSObject.Properties) {
                        $newName = "WPFInstall$($property.Name)"
                        $newObject | Add-Member -MemberType NoteProperty -Name $newName -Value $property.Value
                    }
                    $jsonAsObject = $newObject
                }

                # Format JSON properly for embedding
                $formattedJson = $jsonAsObject | ConvertTo-Json -Depth 10 -Compress:$false
                
                $configScript = "`$sync.configs.$($_.BaseName) = ConvertFrom-Json @'`r`n$formattedJson`r`n'@"
                $script_content.Add($configScript)
                
                Write-Host "Added config: $($_.Name)" -ForegroundColor Yellow
            }
        }
        catch {
            Write-Warning "Failed to process config $($_.Name): $($_.Exception.Message)"
        }
    }
}

Update-Progress "Adding: XAML" 80
$xamlPath = "xaml\inputXML.xaml"
if (Test-Path $xamlPath) {
    try {
        $xaml = Get-Content $xamlPath -Raw -ErrorAction Stop
        if (-not [string]::IsNullOrWhiteSpace($xaml)) {
            $xamlScript = "`$inputXML = @'`r`n$xaml`r`n'@"
            $script_content.Add($xamlScript)
            Write-Host "Added: XAML interface" -ForegroundColor Magenta
        }
    }
    catch {
        Write-Warning "Failed to read XAML: $($_.Exception.Message)"
    }
} else {
    Write-Warning "XAML file not found: $xamlPath"
}

Update-Progress "Adding: Main Script" 90
$mainScriptPath = "scripts\main.ps1"
if (Test-Path $mainScriptPath) {
    try {
        $mainContent = Get-Content $mainScriptPath -Raw -ErrorAction Stop
        if (-not [string]::IsNullOrWhiteSpace($mainContent)) {
            $script_content.Add($mainContent)
            Write-Host "Added: Main execution script" -ForegroundColor Green
        }
    }
    catch {
        Write-Warning "Failed to read main script: $($_.Exception.Message)"
    }
} else {
    Write-Warning "Main script not found: $mainScriptPath"
}

# Debug file handling
if ($Debug) {
    Update-Progress "Writing debug files" 95
    $debugDir = "debug"
    if (-not (Test-Path $debugDir)) {
        New-Item -ItemType Directory -Path $debugDir -Force | Out-Null
    }
    
    # Save individual components for debugging
    try {
        $script_content[0] | Out-File -FilePath "$debugDir\header.txt" -Encoding UTF8
        if ($script_content.Count -gt 1) {
            $script_content[1] | Out-File -FilePath "$debugDir\start.ps1" -Encoding UTF8
        }
        Write-Host "Debug files written to $debugDir" -ForegroundColor Yellow
    }
    catch {
        Write-Warning "Failed to write debug files: $($_.Exception.Message)"
    }
} else {
    Update-Progress "Removing temporary files" 95
    # Clean up any temporary files
    Remove-Item "debug" -Recurse -Force -ErrorAction SilentlyContinue
}

# Write the final script with better error handling
Update-Progress "Writing final script" 98
try {
    $finalContent = $script_content -join "`r`n`r`n"
    
    # Use UTF8 without BOM for better compatibility
    $utf8NoBom = New-Object System.Text.UTF8Encoding($false)
    [System.IO.File]::WriteAllText((Join-Path $workingdir $scriptname), $finalContent, $utf8NoBom)
    
    $fileSize = [math]::Round((Get-Item $scriptname).Length / 1KB, 2)
    Write-Host "`nCompilation completed successfully!" -ForegroundColor Green
    Write-Host "Output: $scriptname ($fileSize KB)" -ForegroundColor White
    Write-Host "Components included: $($script_content.Count)" -ForegroundColor Cyan
}
catch {
    Write-Error "Failed to write final script: $($_.Exception.Message)"
    Pop-Location
    exit 1
}

Write-Progress -Activity "Compiling WDCA" -Completed

Update-Progress -Activity "Validating" -StatusMessage "Checking wdca.ps1 Syntax" -Percent 99
try {
    # Syntax validation
    $errors = $null
    $tokens = $null
    $ast = [System.Management.Automation.Language.Parser]::ParseFile((Join-Path $workingdir $scriptname), [ref]$tokens, [ref]$errors)
    
    if ($errors.Count -gt 0) {
        Write-Warning "Syntax validation found issues:"
        foreach ($error in $errors) {
            Write-Warning "  Line $($error.Extent.StartLineNumber): $($error.Message)"
        }
        Pop-Location
        exit 1
    } else {
        Write-Host "Syntax validation passed!" -ForegroundColor Green
    }
}
catch {
    Write-Warning "Syntax validation failed: $($_.Exception.Message)"
    Pop-Location
    exit 1
}

Write-Progress -Activity "Validating" -Completed

# Run the script if requested
if ($Run) {
    Write-Host "`nStarting WDCA..." -ForegroundColor Cyan
    
    $script = "& '$workingdir\$scriptname'"
    if ($Arguments) {
        $script += " $Arguments"
    }

    $powershellcmd = if (Get-Command pwsh -ErrorAction SilentlyContinue) { "pwsh" } else { "powershell" }
    $processCmd = if (Get-Command wt.exe -ErrorAction SilentlyContinue) { "wt.exe" } else { $powershellcmd }

    try {
        if ($processCmd -eq "wt.exe") {
            Start-Process $processCmd -ArgumentList "$powershellcmd -NoProfile -ExecutionPolicy Bypass -Command `"$script`""
        } else {
            Start-Process $processCmd -ArgumentList "-NoProfile -ExecutionPolicy Bypass -Command `"$script`""
        }
        Write-Host "WDCA started in new window" -ForegroundColor Green
    }
    catch {
        Write-Warning "Failed to start WDCA: $($_.Exception.Message)"
        Write-Host "You can manually run: .\$scriptname" -ForegroundColor Yellow
    }
}

Pop-Location

Write-Host "`nBuild Summary:" -ForegroundColor Cyan
Write-Host "- Script Name: $scriptname" -ForegroundColor White
Write-Host "- File Size: $fileSize KB" -ForegroundColor White
Write-Host "- Components: $($script_content.Count)" -ForegroundColor White
Write-Host "- Debug Mode: $(if ($Debug) { 'Enabled' } else { 'Disabled' })" -ForegroundColor White
Write-Host "- Status: Success" -ForegroundColor Green