################################################################################################################
###                                                                                                          ###
### WARNING: This file is automatically generated DO NOT modify this file directly as it will be overwritten ###
###          Windows Deployment & Configuration Assistant (WDCA)                                           ###
###          Generated: 2025-08-03 15:20:43                                                                                         ###
###                                                                                                          ###
################################################################################################################

#########################################################################
#                                                                       #
# Windows Deployment & Configuration Assistant (WDCA)                  #
# Version: 25.08.03                                                 #
# Author: Tobayashi-san                                                 #
# License: MIT                                                          #
#                                                                       #
#########################################################################

param(
    [string]$Config,
    [switch]$Run,
    [switch]$Debug
)

# Admin check and restart
if (!([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    Write-Host "WDCA needs to run as Administrator. Attempting to restart..." -ForegroundColor Yellow

    try {
        $argList = @()
        $PSBoundParameters.GetEnumerator() | ForEach-Object {
            $argList += if ($_.Value -is [switch] -and $_.Value) {
                "-$($_.Key)"
            } elseif ($_.Value) {
                "-$($_.Key) '$($_.Value)'"
            }
        }

        $script = if ($PSCommandPath) {
            "& `'$PSCommandPath`' $($argList -join ' ')"
        } else {
            $MyInvocation.MyCommand.Definition
        }

        $powershellCmd = if (Get-Command pwsh -ErrorAction SilentlyContinue) { "pwsh" } else { "powershell" }
        $processCmd = if (Get-Command wt.exe -ErrorAction SilentlyContinue) { "wt.exe" } else { $powershellCmd }

        if ($processCmd -eq "wt.exe") {
            Start-Process $processCmd -ArgumentList "$powershellCmd -ExecutionPolicy Bypass -NoProfile -Command `"$script`"" -Verb RunAs
        } else {
            Start-Process $processCmd -ArgumentList "-ExecutionPolicy Bypass -NoProfile -Command `"$script`"" -Verb RunAs
        }

        exit 0
    }
    catch {
        Write-Host "Failed to restart as administrator. Please run PowerShell as Administrator manually." -ForegroundColor Red
        Read-Host "Press Enter to exit"
        exit 1
    }
}

# Set execution policy and initialize
Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
$Host.UI.RawUI.WindowTitle = "WDCA (Admin)"

# Initialize sync hashtable
$global:sync = [Hashtable]::Synchronized(@{})
$global:sync.PSScriptRoot = $PSScriptRoot
$global:sync.configs = @{}
$global:sync.ProcessRunning = $false
$global:sync.logLevel = if ($Debug) { "DEBUG" } else { "INFO" }

# Setup logging
$timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
$logdir = "$env:LOCALAPPDATA\WDCA\logs"
[System.IO.Directory]::CreateDirectory($logdir) | Out-Null
$global:sync.logFile = "$logdir\WDCA_$timestamp.log"

# Store parameters
$global:sync.Config = $Config
$global:sync.Run = $Run
$global:sync.Debug = $Debug

# Welcome message
Clear-Host
Write-Host "============================================================" -ForegroundColor Cyan
Write-Host "Windows Deployment & Configuration Assistant (WDCA)" -ForegroundColor Yellow
Write-Host "Version: 25.08.03" -ForegroundColor Green
Write-Host "============================================================" -ForegroundColor Cyan
Write-Host ""

# Basic checks
if ($PSVersionTable.PSVersion.Major -lt 5) {
    Write-Host "PowerShell 5.0 or higher required. Current: $($PSVersionTable.PSVersion)" -ForegroundColor Red
    Read-Host "Press Enter to exit"
    exit 1
}

try {
    $null = Get-Command winget -ErrorAction Stop
    Write-Host "[OK] WinGet is available" -ForegroundColor Green
}
catch {
    Write-Host "[WARNING] WinGet not available. Some features limited." -ForegroundColor Yellow
}

try {
    Add-Type -AssemblyName PresentationFramework -ErrorAction Stop
    Write-Host "[OK] WPF Framework available" -ForegroundColor Green
}
catch {
    Write-Host "[ERROR] WPF Framework not available. Cannot start GUI." -ForegroundColor Red
    Read-Host "Press Enter to exit"
    exit 1
}

Write-Host "Initialization completed." -ForegroundColor Green
Write-Host ""

function Get-SystemThemePreference {
    <#
    .SYNOPSIS
        Detects the system's current theme preference
    #>

    try {
        $appsUseLightTheme = Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize" -Name "AppsUseLightTheme" -ErrorAction SilentlyContinue

        if ($appsUseLightTheme -and $appsUseLightTheme.AppsUseLightTheme -eq 1) {
            return "Light"
        } else {
            return "Dark"
        }
    }
    catch {
        Write-Logger "Could not detect system theme preference, defaulting to Dark" "WARNING"
        return "Dark"
    }
}

function Initialize-WDCAApplications {
    <#
    .SYNOPSIS
        Initializes the applications panel with modern UI
    #>

    try {
        if (-not $global:sync.configs.applications) {
            Write-Logger "No applications configuration found" "WARNING"
            return
        }

        if (-not $global:sync.WPFApplicationsPanel) {
            Write-Logger "Applications panel not found in UI" "WARNING"
            return
        }

        Write-Logger "Populating applications panel..." "INFO"

        $appsPanel = $global:sync.WPFApplicationsPanel
        $appsCreated = 0

        # Clear existing content
        $appsPanel.Children.Clear() | Out-Null

        # Group applications by category
        $categories = $global:sync.configs.applications.PSObject.Properties |
            Group-Object { $_.Value.category } |
            Sort-Object Name

        foreach ($category in $categories) {
            # Create category card
            $categoryCard = New-Object System.Windows.Controls.Border
            if ($global:sync.Form.Resources["ModernCard"]) {
                $categoryCard.Style = $global:sync.Form.Resources["ModernCard"]
            } else {
                # Fallback styling
                $categoryCard.Background = [System.Windows.Media.Brushes]::DarkGray
                $categoryCard.CornerRadius = "8"
                $categoryCard.Padding = "16"
                $categoryCard.Margin = "0,0,0,16"
            }

            $categoryStack = New-Object System.Windows.Controls.StackPanel

            # Category header
            $categoryLabel = New-Object System.Windows.Controls.TextBlock
            $categoryLabel.Text = $category.Name
            $categoryLabel.FontWeight = "Bold"
            $categoryLabel.FontSize = 16
            $categoryLabel.Margin = "0,0,0,12"
            $categoryLabel.Foreground = [System.Windows.Media.Brushes]::White
            $categoryStack.Children.Add($categoryLabel) | Out-Null

            # Add applications in this category
            foreach ($app in ($category.Group | Sort-Object { $_.Value.content })) {
                # Create checkbox
                $checkbox = New-Object System.Windows.Controls.CheckBox
                $checkboxName = $app.Name  # Already has WPFInstall prefix
                $checkbox.Name = $checkboxName
                $checkbox.Content = $app.Value.content
                $checkbox.ToolTip = $app.Value.description
                $checkbox.Margin = "0,0,0,8"
                $checkbox.Foreground = [System.Windows.Media.Brushes]::White
                $checkbox.FontSize = 12

                # Apply modern style if available
                if ($global:sync.Form.Resources["FluentCheckBox"]) {
                    $checkbox.Style = $global:sync.Form.Resources["FluentCheckBox"]
                }

                $categoryStack.Children.Add($checkbox) | Out-Null

                # Store reference in sync hashtable
                $global:sync[$checkboxName] = $checkbox
                $appsCreated++
            }

            $categoryCard.Child = $categoryStack
            $appsPanel.Children.Add($categoryCard) | Out-Null
        }
    }
    catch {
        Write-Logger "Error initializing applications: $($_.Exception.Message)" "ERROR"
        Write-Host "Detailed error: $($_.Exception)" -ForegroundColor Red
    }
}


function Initialize-ThemeManager {
    <#
    .SYNOPSIS
        Initializes the theme management system for WDCA
    #>

    # Define theme configurations
    $global:WDCAThemes = @{
        "Dark" = @{
            # System Colors
            SystemAccent = "#FF0078D4"
            SystemAccentLight = "#FF429CE3"
            SystemAccentDark = "#FF005A9E"

            # Background Colors
            LayerBackground = "#FF202020"
            SurfaceBackground = "#FF1A1A1A"
            CardBackground = "#FF2D2D30"
            HoverBackground = "#FF3C3C3C"

            # Text Colors
            TextPrimary = "#FFFFFFFF"
            TextSecondary = "#FFE0E0E0"
            TextTertiary = "#FFB0B0B0"

            # Border Colors
            Border = "#FF404040"
            BorderHover = "#FF0078D4"

            # Status Colors
            Success = "#FF107C10"
            Warning = "#FFFF8C00"
            Danger = "#FFD13438"
            Info = "#FF0078D4"
        }

        "Light" = @{
            # System Colors
            SystemAccent = "#FF0078D4"
            SystemAccentLight = "#FF429CE3"
            SystemAccentDark = "#FF005A9E"

            # Background Colors
            LayerBackground = "#FFF0F0F0"
            SurfaceBackground = "#FFFFFFFF"
            CardBackground = "#FFFFFFFF"
            HoverBackground = "#FFF5F5F5"

            # Text Colors
            TextPrimary = "#FF000000"
            TextSecondary = "#FF333333"
            TextTertiary = "#FF666666"

            # Border Colors
            Border = "#FFD1D1D1"
            BorderHover = "#FF0078D4"

            # Status Colors
            Success = "#FF107C10"
            Warning = "#FFFF8C00"
            Danger = "#FFD13438"
            Info = "#FF0078D4"
        }
    }

    Write-Logger "Theme manager initialized with $(($global:WDCAThemes.Keys).Count) themes" "INFO"
}

function Initialize-WDCAVariables {
    <#
    .SYNOPSIS
        Safely creates variables for all named XAML elements
    #>

    try {
        Write-Logger "Creating XAML element variables..." "INFO"

        # Get all named elements from XAML
        $namedElements = $XAML.SelectNodes("//*[@Name]")
        $elementCount = 0
        $duplicateCount = 0

        foreach ($element in $namedElements) {
            $elementName = $element.Name

            try {
                # Check if variable already exists
                if ($global:sync.ContainsKey($elementName)) {
                    Write-Logger "Variable $elementName already exists, skipping..." "DEBUG"
                    $duplicateCount++
                    continue
                }

                # Find the actual UI element
                $uiElement = $global:sync.Form.FindName($elementName)

                if ($uiElement) {
                    $global:sync[$elementName] = $uiElement
                    $elementCount++
                    Write-Logger "Created variable: $elementName" "DEBUG"
                } else {
                    Write-Logger "UI element not found: $elementName" "WARNING"
                }
            }
            catch {
                Write-Logger "Error creating variable for $elementName`: $($_.Exception.Message)" "WARNING"
            }
        }

        Write-Logger "Created $elementCount UI element variables ($duplicateCount duplicates skipped)" "INFO"
    }
    catch {
        Write-Logger "Error initializing XAML variables: $($_.Exception.Message)" "ERROR"
    }
}


function Initialize-WindowControls {
    <#
    .SYNOPSIS
        Initializes window control event handlers for standard Windows controls
    #>

    try {

        if ($global:sync.Form) {
            # Window state change events (optional)
            $global:sync.Form.Add_StateChanged({
                try {
                    $state = $global:sync.Form.WindowState
                    Write-Logger "Window state changed to: $state" "DEBUG"
                }
                catch {
                    Write-Logger "Error in StateChanged event: $($_.Exception.Message)" "DEBUG"
                }
            })

            # Window closing event (wichtig fÃ¼r Cleanup)
            $global:sync.Form.Add_Closing({
                try {
                    Write-Logger "Application closing" "INFO"
                    Stop-AllAsyncOperations
                }
                catch {
                    Write-Logger "Error during window close cleanup: $($_.Exception.Message)" "ERROR"
                }
            })
        }
    }
    catch {
        Write-Logger "Error initializing window controls: $($_.Exception.Message)" "ERROR"
    }
}

function Set-WDCAStatus {
    <#
    .SYNOPSIS
        Updates the WDCA status bar

    .DESCRIPTION
        Convenience function to update the status bar text

    .PARAMETER Status
        The status message to display

    .EXAMPLE
        Set-WDCAStatus "Ready for operations"
    #>

    param([string]$Status)

    if ($global:sync.WPFStatusText) {
        $global:sync.WPFStatusText.Dispatcher.Invoke([action]{
            $global:sync.WPFStatusText.Text = $Status
        })
    }

    Write-Logger $Status "INFO" $false
}

function Set-WDCATheme {
    <#
    .SYNOPSIS
        Applies a theme to the WDCA application

    .PARAMETER ThemeName
        Name of the theme to apply (Dark, Light)
    #>

    param(
        [Parameter(Mandatory = $true)]
        [ValidateSet("Dark", "Light")]
        [string]$ThemeName
    )

    if (-not $global:WDCAThemes) {
        Initialize-ThemeManager
    }

    $theme = $global:WDCAThemes[$ThemeName]

    if (-not $theme) {
        Write-Logger "Theme '$ThemeName' not found" "ERROR"
        return
    }

    try {
        Write-Logger "Applying theme: $ThemeName" "INFO"

        # Update resource dictionary with new theme colors
        if ($global:sync.Form -and $global:sync.Form.Resources) {
            $resources = $global:sync.Form.Resources

            # Update color resources
            foreach ($colorName in $theme.Keys) {
                # Skip non-color properties
                if ($colorName -like "*Opacity" -or $colorName -like "*Radius" -or $colorName -like "*Thickness") {
                    continue
                }

                $resourceKey = "${colorName}Brush"
                $colorValue = $theme[$colorName]

                try {
                    $brush = New-Object System.Windows.Media.SolidColorBrush
                    $brush.Color = [System.Windows.Media.ColorConverter]::ConvertFromString($colorValue)

                    if ($resources.Contains($resourceKey)) {
                        $resources[$resourceKey] = $brush
                    } else {
                        $resources.Add($resourceKey, $brush)
                    }
                }
                catch {
                    Write-Logger "Error setting color resource $resourceKey`: $($_.Exception.Message)" "DEBUG"
                }
            }

            Write-Logger "Theme '$ThemeName' applied successfully" "INFO"
        }
    }
    catch {
        Write-Logger "Error applying theme '$ThemeName': $($_.Exception.Message)" "ERROR"
    }
}

function Start-AsyncOperation {
    <#
    .SYNOPSIS
        Enhanced async operation manager with improved error handling and monitoring

    .PARAMETER ScriptBlock
        The script block to execute asynchronously

    .PARAMETER ProgressCallback
        Callback for progress updates

    .PARAMETER CompletedCallback
        Callback when operation completes

    .PARAMETER OperationName
        Name of the operation for tracking and logging

    .PARAMETER TimeoutSeconds
        Maximum time to wait for operation completion (default: 3600 seconds)

    .PARAMETER AllowCancel
        Whether the operation can be cancelled by user (default: true)

    .EXAMPLE
        Start-AsyncOperation -ScriptBlock { Get-Process } -OperationName "Process List" -CompletedCallback { param($result) Write-Host $result.Count }
    #>

    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ScriptBlock]$ScriptBlock,

        [Parameter(Mandatory = $false)]
        [ScriptBlock]$ProgressCallback,

        [Parameter(Mandatory = $false)]
        [ScriptBlock]$CompletedCallback,

        [Parameter(Mandatory = $false)]
        [string]$OperationName = "Background Operation",

        [Parameter(Mandatory = $false)]
        [int]$TimeoutSeconds = 3600,

        [Parameter(Mandatory = $false)]
        [bool]$AllowCancel = $true
    )

    try {
        Write-Logger "Starting async operation: $OperationName" "INFO" -Category "AsyncOps"

        # Initialize async operations tracking if not exists
        if (-not $global:AsyncOperations) {
            $global:AsyncOperations = [System.Collections.Concurrent.ConcurrentDictionary[string, object]]::new()
        }

        # Generate unique operation ID
        $operationId = [System.Guid]::NewGuid().ToString()

        # Save current UI state
        Save-UIState

        # Disable UI elements
        Set-UIEnabled -Enabled $false

        # Initialize or get runspace pool
        $runspacePool = Get-RunspacePool

        # Create PowerShell instance
        $powershell = [PowerShell]::Create()
        $powershell.RunspacePool = $runspacePool

        # Enhanced script wrapper with better error handling
        $wrappedScript = {
            param($ScriptBlock, $OperationName, $OperationId)

            $result = @{
                Success = $false
                Result = $null
                Error = $null
                OperationId = $OperationId
                StartTime = Get-Date
                EndTime = $null
                Duration = $null
                MemoryUsed = 0
                CpuTime = 0
            }

            try {
                # Capture initial performance metrics
                $process = Get-Process -Id $PID
                $initialMemory = $process.WorkingSet64
                $initialCpuTime = $process.TotalProcessorTime

                Write-Verbose "Executing async operation: $OperationName"

                # Execute the actual work
                $result.Result = Invoke-Command -ScriptBlock $ScriptBlock
                $result.Success = $true

                # Capture final performance metrics
                $process = Get-Process -Id $PID
                $result.MemoryUsed = [math]::Round(($process.WorkingSet64 - $initialMemory) / 1MB, 2)
                $result.CpuTime = ($process.TotalProcessorTime - $initialCpuTime).TotalSeconds

                Write-Verbose "Async operation completed successfully: $OperationName"
            }
            catch {
                $result.Error = @{
                    Message = $_.Exception.Message
                    FullError = $_.Exception.ToString()
                    ScriptStackTrace = $_.ScriptStackTrace
                    CategoryInfo = $_.CategoryInfo.ToString()
                }
                Write-Verbose "Async operation failed: $OperationName - $($_.Exception.Message)"
            }
            finally {
                $result.EndTime = Get-Date
                $result.Duration = ($result.EndTime - $result.StartTime).TotalSeconds
            }

            return $result
        }

        # Add script to PowerShell instance
        [void]$powershell.AddScript($wrappedScript).AddParameter("ScriptBlock", $ScriptBlock).AddParameter("OperationName", $OperationName).AddParameter("OperationId", $operationId)

        # Start async execution
        $asyncResult = $powershell.BeginInvoke()

        # Create operation context
        $operationContext = @{
            OperationId = $operationId
            OperationName = $OperationName
            PowerShell = $powershell
            AsyncResult = $asyncResult
            RunspacePool = $runspacePool
            ProgressCallback = $ProgressCallback
            CompletedCallback = $CompletedCallback
            StartTime = Get-Date
            TimeoutTime = (Get-Date).AddSeconds($TimeoutSeconds)
            AllowCancel = $AllowCancel
            IsCancelled = $false
            IsCompleted = $false
            Timer = $null
        }

        # Store operation in global tracking
        $global:AsyncOperations[$operationId] = $operationContext

        # Create monitoring timer
        $timer = New-Object System.Windows.Threading.DispatcherTimer
        $timer.Interval = [TimeSpan]::FromMilliseconds(250)
        $operationContext.Timer = $timer

        # Timer tick event for monitoring
        $timer.Add_Tick({
            try {
                $context = $global:AsyncOperations[$operationId]
                if (-not $context -or $context.IsCompleted) {
                    return
                }

                $currentTime = Get-Date

                # Check for timeout
                if ($currentTime -gt $context.TimeoutTime) {
                    Write-Logger "Operation timed out: $($context.OperationName)" "WARNING" -Category "AsyncOps"
                    Stop-AsyncOperation -OperationId $operationId -Reason "Timeout"
                    return
                }

                # Check if operation is complete
                if ($context.AsyncResult.IsCompleted) {
                    Complete-AsyncOperation -OperationId $operationId
                    return
                }

                # Execute progress callback if provided
                if ($context.ProgressCallback) {
                    try {
                        $elapsed = ($currentTime - $context.StartTime).TotalSeconds
                        & $context.ProgressCallback $elapsed
                    }
                    catch {
                        Write-Logger "Progress callback failed for $($context.OperationName): $($_.Exception.Message)" "WARNING" -Category "AsyncOps"
                    }
                }

                # Update progress indicator
                $elapsed = [math]::Round(($currentTime - $context.StartTime).TotalSeconds)
                Update-ProgressSafe -Message "Running $($context.OperationName)... (${elapsed}s)" -PercentComplete -1

            }
            catch {
                Write-Logger "Timer tick error for operation $operationId`: $($_.Exception.Message)" "ERROR" -Category "AsyncOps"
                Stop-AsyncOperation -OperationId $operationId -Reason "Timer Error"
            }
        })

        # Start monitoring timer
        $timer.Start()

        Write-Logger "Async operation started: $OperationName (ID: $operationId)" "SUCCESS" -Category "AsyncOps"
        Set-WDCAStatus "Running $OperationName..."

        return $operationId

    }
    catch {
        Write-Logger "Failed to start async operation: $($_.Exception.Message)" "ERROR" -Category "AsyncOps"

        # Restore UI state on failure
        Restore-UIState
        Reset-ProgressBar

        throw
    }
}

function Complete-AsyncOperation {
    <#
    .SYNOPSIS
        Completes an async operation and handles cleanup
    #>

    param([string]$OperationId)

    try {
        $context = $global:AsyncOperations[$OperationId]
        if (-not $context -or $context.IsCompleted) {
            return
        }

        # Mark as completed to prevent double execution
        $context.IsCompleted = $true

        # Stop and cleanup timer
        if ($context.Timer) {
            $context.Timer.Stop()
            $context.Timer = $null
        }

        # Get results
        $result = $context.PowerShell.EndInvoke($context.AsyncResult)
        $context.PowerShell.Dispose()

        $duration = ((Get-Date) - $context.StartTime).TotalSeconds

        if ($result -and $result.Success) {
            Write-Logger "$($context.OperationName) completed successfully in $([math]::Round($duration, 2))s" "SUCCESS" -Category "AsyncOps"

            # Log performance metrics if available
            if ($result.MemoryUsed -ne 0 -or $result.CpuTime -ne 0) {
                Write-Logger "Performance: Memory: $($result.MemoryUsed)MB, CPU: $($result.CpuTime)s" "TRACE" -Category "Performance"
            }

            # Execute completion callback
            if ($context.CompletedCallback) {
                try {
                    & $context.CompletedCallback $result.Result
                }
                catch {
                    Write-Logger "Completion callback failed for $($context.OperationName): $($_.Exception.Message)" "ERROR" -Category "AsyncOps"
                    Show-ErrorDialog -Title "Operation Completed with Errors" -Message "The operation completed but there was an error processing the results: $($_.Exception.Message)"
                }
            }
        }
        else {
            $errorMsg = if ($result.Error) { $result.Error.Message } else { "Unknown error occurred" }
            Write-Logger "$($context.OperationName) failed: $errorMsg" "ERROR" -Category "AsyncOps"

            # Log detailed error information
            if ($result.Error -and $result.Error.FullError) {
                Write-Logger "Detailed error: $($result.Error.FullError)" "DEBUG" -Category "AsyncOps"
            }

            # Show error to user
            Show-ErrorDialog -Title "Operation Failed" -Message "Operation failed: $errorMsg"
        }

        # Cleanup and restore UI
        Cleanup-AsyncOperation -OperationId $OperationId

    }
    catch {
        Write-Logger "Error completing async operation $OperationId`: $($_.Exception.Message)" "ERROR" -Category "AsyncOps"
        Cleanup-AsyncOperation -OperationId $OperationId
    }
}

function Stop-AsyncOperation {
    <#
    .SYNOPSIS
        Stops a running async operation
    #>

    param(
        [string]$OperationId,
        [string]$Reason = "User Request"
    )

    try {
        $context = $global:AsyncOperations[$OperationId]
        if (-not $context) {
            return
        }

        Write-Logger "Stopping async operation: $($context.OperationName) - Reason: $Reason" "WARNING" -Category "AsyncOps"

        $context.IsCancelled = $true
        $context.IsCompleted = $true

        # Stop timer
        if ($context.Timer) {
            $context.Timer.Stop()
            $context.Timer = $null
        }

        # Stop PowerShell execution
        if ($context.PowerShell -and -not $context.AsyncResult.IsCompleted) {
            try {
                $context.PowerShell.Stop()
                # Give it a moment to stop gracefully
                Start-Sleep -Milliseconds 500
            }
            catch {
                Write-Logger "Error stopping PowerShell instance: $($_.Exception.Message)" "WARNING" -Category "AsyncOps"
            }
        }

        # Cleanup
        Cleanup-AsyncOperation -OperationId $OperationId

        Set-WDCAStatus "Operation cancelled: $($context.OperationName)"

    }
    catch {
        Write-Logger "Error stopping async operation $OperationId`: $($_.Exception.Message)" "ERROR" -Category "AsyncOps"
    }
}

function Cleanup-AsyncOperation {
    <#
    .SYNOPSIS
        Cleans up resources from an async operation
    #>

    param([string]$OperationId)

    try {
        $context = $global:AsyncOperations[$OperationId]
        if ($context) {
            # Dispose PowerShell instance if not already done
            if ($context.PowerShell) {
                try {
                    $context.PowerShell.Dispose()
                }
                catch {
                    Write-Logger "Error disposing PowerShell instance: $($_.Exception.Message)" "WARNING" -Category "AsyncOps"
                }
            }

            # Remove from tracking
            $global:AsyncOperations.TryRemove($OperationId, [ref]$null) | Out-Null
        }

        # Check if this was the last operation
        if ($global:AsyncOperations.Count -eq 0) {
            # Restore UI state
            Restore-UIState
            Reset-ProgressBar
            Set-WDCAStatus "Ready"

            # Trigger garbage collection to clean up resources
            [System.GC]::Collect()
            [System.GC]::WaitForPendingFinalizers()
        }

    }
    catch {
        Write-Logger "Error during async operation cleanup: $($_.Exception.Message)" "ERROR" -Category "AsyncOps"
    }
}

function Get-RunspacePool {
    <#
    .SYNOPSIS
        Gets or creates the global runspace pool
    #>

    if (-not $global:RunspacePool -or $global:RunspacePool.RunspacePoolStateInfo.State -ne 'Opened') {
        try {
            # Determine optimal thread count
            $maxThreads = [math]::Min([Environment]::ProcessorCount * 2, 8)
            $minThreads = [math]::Max([Environment]::ProcessorCount, 2)

            Write-Logger "Initializing runspace pool with $minThreads-$maxThreads threads" "INFO" -Category "AsyncOps"

            # Create initial session state with required modules and variables
            $initialSessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()

            # Add sync variable to session state
            $syncVariable = New-Object System.Management.Automation.Runspaces.SessionStateVariableEntry('sync', $global:sync, $null)
            $initialSessionState.Variables.Add($syncVariable)

            # Create runspace pool
            $global:RunspacePool = [runspacefactory]::CreateRunspacePool(
                $minThreads,
                $maxThreads,
                $initialSessionState,
                $Host
            )

            $global:RunspacePool.Open()

}
        catch {
            Write-Logger "Failed to initialize runspace pool: $($_.Exception.Message)" "ERROR" -Category "AsyncOps"
            throw
        }
    }

    return $global:RunspacePool
}

function Stop-AllAsyncOperations {
    <#
    .SYNOPSIS
        Stops all running async operations
    #>

    try {
        if (-not $global:AsyncOperations -or $global:AsyncOperations.Count -eq 0) {
            return
        }

        Write-Logger "Stopping all async operations ($($global:AsyncOperations.Count) active)" "WARNING" -Category "AsyncOps"

        # Get all operation IDs to avoid modification during enumeration
        $operationIds = $global:AsyncOperations.Keys | ForEach-Object { $_ }

        foreach ($operationId in $operationIds) {
            Stop-AsyncOperation -OperationId $operationId -Reason "Application Shutdown"
        }

        # Force cleanup if anything remains
        $global:AsyncOperations.Clear()

        # Restore UI
        Restore-UIState
        Reset-ProgressBar

        Write-Logger "All async operations stopped" "INFO" -Category "AsyncOps"

    }
    catch {
        Write-Logger "Error stopping all async operations: $($_.Exception.Message)" "ERROR" -Category "AsyncOps"
    }
}

function Get-ActiveAsyncOperations {
    <#
    .SYNOPSIS
        Returns information about active async operations
    #>

    if (-not $global:AsyncOperations) {
        return @()
    }

    $activeOps = @()
    foreach ($context in $global:AsyncOperations.Values) {
        if (-not $context.IsCompleted -and -not $context.IsCancelled) {
            $elapsed = ((Get-Date) - $context.StartTime).TotalSeconds
            $activeOps += [PSCustomObject]@{
                OperationId = $context.OperationId
                OperationName = $context.OperationName
                ElapsedSeconds = [math]::Round($elapsed, 1)
                StartTime = $context.StartTime
                AllowCancel = $context.AllowCancel
            }
        }
    }

    return $activeOps
}

function Show-ErrorDialog {
    <#
    .SYNOPSIS
        Shows an error dialog to the user
    #>

    param(
        [string]$Title = "Error",
        [string]$Message
    )

    try {
        if ($global:sync.Form) {
            $global:sync.Form.Dispatcher.Invoke([System.Action]{
                [System.Windows.MessageBox]::Show(
                    $Message,
                    "WDCA - $Title",
                    [System.Windows.MessageBoxButton]::OK,
                    [System.Windows.MessageBoxImage]::Error
                )
            })
        }
        else {
            Write-Host "ERROR: $Message" -ForegroundColor Red
        }
    }
    catch {
        Write-Logger "Failed to show error dialog: $($_.Exception.Message)" "ERROR" -Category "UI"
    }
}

function Test-IsAdmin {
    <#
    .SYNOPSIS
        Tests if the current user has administrator privileges

    .DESCRIPTION
        Checks if the current PowerShell session is running with administrator rights

    .EXAMPLE
        Test-IsAdmin
    #>

    $currentUser = [Security.Principal.WindowsIdentity]::GetCurrent()
    $principal = New-Object Security.Principal.WindowsPrincipal($currentUser)
    return $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
}

function Set-UIEnabled {
    <#
    .SYNOPSIS
        Aktiviert oder deaktiviert UI-Elemente

    .PARAMETER Enabled
        $true um UI zu aktivieren, $false um zu deaktivieren
    #>

    param([bool]$Enabled)

    try {
        if ($global:sync.Form) {
            $global:sync.Form.Dispatcher.Invoke([action]{
                # Haupt-Buttons deaktivieren/aktivieren
                $buttonNames = @(
                    "WPFInstallSelectedApps", "WPFSelectAllApps", "WPFDeselectAllApps",
                    "WPFConfigureNetwork", "WPFEnableRDP", "WPFApplyRole",
                    "WPFRunDiagnostics", "WPFRunDISM", "WPFRunSFC", "WPFRunCHKDSK", "WPFNetworkDiagnostics",
                    "WPFCheckUpdates", "WPFInstallUpdates", "WPFUpdateApps", "WPFUpgradeApps", "WPFPrepareUpgrade",
                    "WPFRunSysprep", "WPFRunCleanup", "WPFPrepareSysprep"
                )

                foreach ($buttonName in $buttonNames) {
                    if ($global:sync[$buttonName]) {
                        $global:sync[$buttonName].IsEnabled = $Enabled
                    }
                }

                # Navigation nur bei grossen Operationen deaktivieren
                if (-not $Enabled) {
                    $navButtons = @("NavApplications", "NavSystemSetup", "NavTroubleshooting", "NavUpdates", "NavCloning")
                    foreach ($navButton in $navButtons) {
                        if ($global:sync[$navButton]) {
                            $global:sync[$navButton].IsEnabled = $false
                        }
                    }
                } else {
                    $navButtons = @("NavApplications", "NavSystemSetup", "NavTroubleshooting", "NavUpdates", "NavCloning", "NavSettings", "NavAbout")
                    foreach ($navButton in $navButtons) {
                        if ($global:sync[$navButton]) {
                            $global:sync[$navButton].IsEnabled = $true
                        }
                    }
                }
            })
        }
    }
    catch {
        Write-Logger "Error setting UI enabled state: $($_.Exception.Message)" "ERROR"
    }
}

function Update-ProgressSafe {
    <#
    .SYNOPSIS
        Thread-sichere Progress-Update Funktion

    .PARAMETER Message
        Nachricht fuer die Fortschrittsanzeige

    .PARAMETER PercentComplete
        Fortschritt in Prozent (0-100), -1 fuer unbestimmten Fortschritt
    #>

    param(
        [string]$Message,
        [int]$PercentComplete = -1
    )

    try {
        if ($global:sync.Form) {
            $global:sync.Form.Dispatcher.Invoke([action]{
                # Progress Bar aktualisieren
                if ($global:sync.WPFProgressBar) {
                    if ($PercentComplete -ge 0 -and $PercentComplete -le 100) {
                        $global:sync.WPFProgressBar.Value = $PercentComplete
                        $global:sync.WPFProgressBar.IsIndeterminate = $false
                        $global:sync.WPFProgressBar.Visibility = "Visible"
                    }
                    elseif ($PercentComplete -eq -1) {
                        $global:sync.WPFProgressBar.IsIndeterminate = $true
                        $global:sync.WPFProgressBar.Visibility = "Visible"
                    }
                    else {
                        $global:sync.WPFProgressBar.Visibility = "Collapsed"
                    }
                }

                # Status Text aktualisieren
                if ($global:sync.WPFStatusText -and $Message) {
                    $global:sync.WPFStatusText.Text = $Message
                }
            })
        }
    }
    catch {
        Write-Logger "Error updating progress: $($_.Exception.Message)" "DEBUG"
    }
}

function Add-DiagnosticResultSafe {
    <#
    .SYNOPSIS
        Thread-sichere Diagnostic Results Funktion

    .PARAMETER Text
        Text der zu den Diagnostic Results hinzugefuegt werden soll
    #>

    param([string]$Text)

    try {
        if ($global:sync.WPFDiagnosticResults) {
            $global:sync.WPFDiagnosticResults.Dispatcher.Invoke([action]{
                $global:sync.WPFDiagnosticResults.AppendText("$Text`r`n")
                $global:sync.WPFDiagnosticResults.ScrollToEnd()
            })
        }
    }
    catch {
        Write-Logger "Error adding diagnostic result: $($_.Exception.Message)" "DEBUG"
    }
}

function Reset-ProgressBar {
    <#
    .SYNOPSIS
        Versteckt und resettet die Progress Bar
    #>

    try {
        if ($global:sync.WPFProgressBar) {
            $global:sync.WPFProgressBar.Dispatcher.Invoke([action]{
                $global:sync.WPFProgressBar.Value = 0
                $global:sync.WPFProgressBar.IsIndeterminate = $false
                $global:sync.WPFProgressBar.Visibility = "Collapsed"
            })
        }
    }
    catch {
        Write-Logger "Error resetting progress bar: $($_.Exception.Message)" "DEBUG"
    }
}

function Show-OperationDialog {
    <#
    .SYNOPSIS
        Zeigt einen modalen Dialog fuer laufende Operationen

    .PARAMETER Title
        Titel des Dialogs

    .PARAMETER Message
        Nachricht im Dialog

    .PARAMETER AllowCancel
        Ob der Dialog einen Cancel-Button haben soll
    #>

    param(
        [string]$Title = "Operation in Progress",
        [string]$Message = "Please wait...",
        [bool]$AllowCancel = $true
    )

    # Einfache Implementation - koennte spaeter erweitert werden
    try {
        if ($global:sync.Form -and $AllowCancel) {
            $result = [System.Windows.MessageBox]::Show(
                $Message + "`n`nPress OK to continue or Cancel to stop.",
                "WDCA - $Title",
                [System.Windows.MessageBoxButton]::OKCancel,
                [System.Windows.MessageBoxImage]::Information
            )

            return $result -eq [System.Windows.MessageBoxResult]::OK
        }
    }
    catch {
        Write-Logger "Error showing operation dialog: $($_.Exception.Message)" "ERROR"
    }

    return $true
}

function Test-UIResponsive {
    <#
    .SYNOPSIS
        Testet ob die UI noch responsive ist
    #>

    try {
        if ($global:sync.Form) {
            $responsive = $false
            $global:sync.Form.Dispatcher.Invoke([action]{
                $responsive = $global:sync.Form.IsLoaded
            }, [System.Windows.Threading.DispatcherPriority]::Normal, [System.Threading.CancellationToken]::None, [System.TimeSpan]::FromMilliseconds(100))

            return $responsive
        }
    }
    catch {
        return $false
    }

    return $false
}

function Update-UIStatus {
    <#
    .SYNOPSIS
        Aktualisiert verschiedene UI-Status-Indikatoren

    .PARAMETER StatusMessage
        Status-Nachricht

    .PARAMETER OperationsCount
        Anzahl aktiver Operationen

    .PARAMETER LastOperation
        Name der letzten Operation
    #>

    param(
        [string]$StatusMessage,
        [int]$OperationsCount = 0,
        [string]$LastOperation = ""
    )

    try {
        if ($global:sync.Form) {
            $global:sync.Form.Dispatcher.Invoke([action]{
                # Status Text aktualisieren
                if ($global:sync.WPFStatusText -and $StatusMessage) {
                    $statusWithIndicator = if ($OperationsCount -gt 0) {
                        "$StatusMessage ($OperationsCount active)"
                    } else {
                        $StatusMessage
                    }
                    $global:sync.WPFStatusText.Text = $statusWithIndicator
                }

                # Titel Bar aktualisieren falls noetig
                if ($global:sync.Form.Title -and $OperationsCount -gt 0) {
                    if (-not $global:sync.Form.Title.Contains("- Running")) {
                        $global:sync.Form.Title = "WDCA - Running Operation"
                    }
                } elseif ($global:sync.Form.Title -and $OperationsCount -eq 0) {
                    $global:sync.Form.Title = "Windows Deployment and Configuration Assistant"
                }
            })
        }
    }
    catch {
        Write-Logger "Error updating UI status: $($_.Exception.Message)" "DEBUG"
    }
}

function Write-Logger {
    <#
    .SYNOPSIS
        Advanced logging function for WDCA with enhanced features

    .DESCRIPTION
        Centralized logging function that supports multiple log levels, colored console output,
        file logging with timestamps, and thread-safe operations

    .PARAMETER Message
        The message to log

    .PARAMETER Level
        Log level (INFO, WARNING, ERROR, DEBUG, SUCCESS, TRACE)

    .PARAMETER WriteToConsole
        Whether to write to console (default: true)

    .PARAMETER WriteToFile
        Whether to write to log file (default: true)

    .PARAMETER Category
        Optional category for the log entry

    .PARAMETER Source
        Optional source component that generated the log

    .EXAMPLE
        Write-Logger "Application installation started" "INFO"
        Write-Logger "Failed to install application" "ERROR" -Category "Installation"
        Write-Logger "Debug information" "DEBUG" -Source "NetworkConfig"
    #>

    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [string]$Message,

        [Parameter(Mandatory = $false)]
        [ValidateSet("INFO", "WARNING", "ERROR", "DEBUG", "SUCCESS", "TRACE")]
        [string]$Level = "INFO",

        [Parameter(Mandatory = $false)]
        [bool]$WriteToConsole = $true,

        [Parameter(Mandatory = $false)]
        [bool]$WriteToFile = $true,

        [Parameter(Mandatory = $false)]
        [string]$Category = "",

        [Parameter(Mandatory = $false)]
        [string]$Source = ""
    )

    begin {
        # Initialize if not already done
        if (-not $global:sync) {
            $global:sync = @{}
        }

        if (-not $global:sync.LoggingInitialized) {
            Initialize-Logging
        }
    }

    process {
        try {
            # Create timestamp
            $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"

            # Build log entry components
            $logComponents = @()
            $logComponents += "[$timestamp]"
            $logComponents += "[$Level]"

            if ($Source) {
                $logComponents += "[$Source]"
            }

            if ($Category) {
                $logComponents += "[$Category]"
            }

            $logComponents += $Message

            # Construct full log entry
            $logEntry = $logComponents -join " "

            # Write to console with colors if enabled
            if ($WriteToConsole) {
                Write-ConsoleWithColor -LogEntry $logEntry -Level $Level -Message $Message
            }

            # Write to file if enabled and available
            if ($WriteToFile -and $global:sync.logFile) {
                Write-LogToFile -LogEntry $logEntry
            }

            # Update UI status if available (thread-safe)
            if ($global:sync.WPFStatusText -and $Level -ne "DEBUG" -and $Level -ne "TRACE") {
                Update-StatusBarSafe -Message $Message
            }

            # Handle error level logging
            if ($Level -eq "ERROR") {
                Handle-ErrorLogging -Message $Message -Source $Source -Category $Category
            }

            # Performance monitoring for trace level
            if ($Level -eq "TRACE" -and $global:sync.Debug) {
                Monitor-Performance -Message $Message
            }

        }
        catch {
            # Fallback logging if main logging fails
            try {
                $fallbackMessage = "[$timestamp] [ERROR] [Logger] Logging failed: $($_.Exception.Message). Original: $Message"
                Write-Host $fallbackMessage -ForegroundColor Red

                if ($global:sync.logFile) {
                    Add-Content -Path $global:sync.logFile -Value $fallbackMessage -Encoding UTF8 -ErrorAction SilentlyContinue
                }
            }
            catch {
                # Ultimate fallback - just write to host
                Write-Host "Critical logging failure - Original message: $Message" -ForegroundColor Red
            }
        }
    }
}

function Initialize-Logging {
    <#
    .SYNOPSIS
        Initializes the logging system
    #>

    try {
        # Set up log rotation if file gets too large (50MB limit)
        if ($global:sync.logFile -and (Test-Path $global:sync.logFile)) {
            $logSize = (Get-Item $global:sync.logFile).Length / 1MB
            if ($logSize -gt 50) {
                $backupLog = $global:sync.logFile -replace '\.log$', "_backup_$(Get-Date -Format 'yyyyMMdd').log"
                Move-Item -Path $global:sync.logFile -Destination $backupLog -Force -ErrorAction SilentlyContinue
            }
        }

        # Initialize performance counters
        $global:sync.LoggingStats = @{
            TotalMessages = 0
            ErrorCount = 0
            WarningCount = 0
            StartTime = Get-Date
        }

        # Set up log levels based on configuration
        $global:sync.LogLevels = @{
            "TRACE" = 0
            "DEBUG" = 1
            "INFO" = 2
            "SUCCESS" = 2
            "WARNING" = 3
            "ERROR" = 4
        }

        $global:sync.CurrentLogLevel = if ($global:sync.Debug) { 0 } else { 2 }
        $global:sync.LoggingInitialized = $true

        # Create log directory if it doesn't exist
        if ($global:sync.logFile) {
            $logDir = Split-Path $global:sync.logFile -Parent
            if (-not (Test-Path $logDir)) {
                New-Item -ItemType Directory -Path $logDir -Force | Out-Null
            }
        }

        Write-Host "Logging system initialized" -ForegroundColor Green
    }
    catch {
        Write-Host "Failed to initialize logging: $($_.Exception.Message)" -ForegroundColor Red
    }
}

function Write-ConsoleWithColor {
    <#
    .SYNOPSIS
        Writes colored output to console based on log level
    #>

    param(
        [string]$LogEntry,
        [string]$Level,
        [string]$Message
    )

    try {
        # Check if we should display this level
        if ($global:sync.LogLevels -and $global:sync.LogLevels.ContainsKey($Level) -and $global:sync.CurrentLogLevel) {
            if ($global:sync.LogLevels[$Level] -lt $global:sync.CurrentLogLevel) {
                return
            }
        }

        $color = switch ($Level) {
            "SUCCESS" { "Green" }
            "INFO" { "White" }
            "WARNING" { "Yellow" }
            "ERROR" { "Red" }
            "DEBUG" { "Cyan" }
            "TRACE" { "DarkGray" }
            default { "White" }
        }

        # Add timestamp for better readability in console
        $consoleMessage = if ($Level -eq "DEBUG" -or $Level -eq "TRACE") {
            $LogEntry
        } else {
            "$(Get-Date -Format 'HH:mm:ss') [$Level] $Message"
        }

        Write-Host $consoleMessage -ForegroundColor $color

        # Update statistics
        if ($global:sync.LoggingStats) {
            $global:sync.LoggingStats.TotalMessages++
            if ($Level -eq "ERROR") { $global:sync.LoggingStats.ErrorCount++ }
            if ($Level -eq "WARNING") { $global:sync.LoggingStats.WarningCount++ }
        }
    }
    catch {
        # Fallback to basic write-host
        Write-Host "$Level`: $Message" -ForegroundColor White
    }
}

function Write-LogToFile {
    <#
    .SYNOPSIS
        Thread-safe file logging
    #>

    param([string]$LogEntry)

    try {
        # Simple file append with retry logic
        $retryCount = 0
        $maxRetries = 3

        do {
            try {
                Add-Content -Path $global:sync.logFile -Value $LogEntry -Encoding UTF8 -ErrorAction Stop
                break
            }
            catch {
                $retryCount++
                if ($retryCount -ge $maxRetries) {
                    # Give up after max retries
                    break
                }
                Start-Sleep -Milliseconds (100 * $retryCount)
            }
        } while ($retryCount -lt $maxRetries)
    }
    catch {
        # Silent fail for file logging to prevent recursive errors
    }
}

function Update-StatusBarSafe {
    <#
    .SYNOPSIS
        Thread-safe status bar updates
    #>

    param([string]$Message)

    try {
        if ($global:sync.WPFStatusText -and $global:sync.Form) {
            $global:sync.Form.Dispatcher.Invoke([System.Action]{
                $global:sync.WPFStatusText.Text = $Message
            }, [System.Windows.Threading.DispatcherPriority]::Background)
        }
    }
    catch {
        # Ignore status bar update errors
    }
}

function Handle-ErrorLogging {
    <#
    .SYNOPSIS
        Special handling for error-level logs
    #>

    param(
        [string]$Message,
        [string]$Source,
        [string]$Category
    )

    try {
        # Store error in error collection for later analysis
        if (-not $global:sync.ErrorLog) {
            $global:sync.ErrorLog = [System.Collections.Generic.List[PSObject]]::new()
        }

        $errorEntry = [PSCustomObject]@{
            Timestamp = Get-Date
            Message = $Message
            Source = $Source
            Category = $Category
            StackTrace = $null
        }

        # Try to get stack trace safely
        try {
            $stackTrace = Get-PSCallStack | Select-Object -Skip 2 | Select-Object -First 3
            $errorEntry.StackTrace = $stackTrace
        }
        catch {
            # If stack trace fails, just continue
        }

        $global:sync.ErrorLog.Add($errorEntry)

        # Keep only last 100 errors to prevent memory issues
        if ($global:sync.ErrorLog.Count -gt 100) {
            $global:sync.ErrorLog.RemoveAt(0)
        }

        # Trigger error notification if UI is available
        if ($global:sync.Form -and $global:sync.ShowErrorNotifications) {
            Show-ErrorNotification -Message $Message
        }
    }
    catch {
        # Don't fail if error handling fails
    }
}

function Monitor-Performance {
    <#
    .SYNOPSIS
        Performance monitoring for trace-level logging
    #>

    param([string]$Message)

    try {
        if (-not $global:sync.PerformanceCounters) {
            $global:sync.PerformanceCounters = @{}
        }

        $process = Get-Process -Id $PID -ErrorAction SilentlyContinue
        if ($process) {
            $memoryUsage = [math]::Round($process.WorkingSet64 / 1MB, 2)
            $cpuTime = $process.TotalProcessorTime.TotalSeconds

            $perfData = "[PERF] Memory: ${memoryUsage}MB, CPU: ${cpuTime}s - $Message"

            if ($global:sync.logFile) {
                Add-Content -Path $global:sync.logFile -Value $perfData -Encoding UTF8 -ErrorAction SilentlyContinue
            }

            # Alert if memory usage is high
            if ($memoryUsage -gt 500) {
                Write-Logger "High memory usage detected: ${memoryUsage}MB" "WARNING" -Category "Performance"
            }
        }
    }
    catch {
        # Don't fail if performance monitoring fails
    }
}

function Show-ErrorNotification {
    <#
    .SYNOPSIS
        Shows error notifications in UI
    #>

    param([string]$Message)

    try {
        if ($global:sync.Form) {
            $global:sync.Form.Dispatcher.Invoke([System.Action]{
                # Create a simple error indicator
                if ($global:sync.ErrorIndicator) {
                    $global:sync.ErrorIndicator.Visibility = "Visible"
                    $global:sync.ErrorIndicator.ToolTip = "Recent error: $Message"
                }
            }, [System.Windows.Threading.DispatcherPriority]::Background)
        }
    }
    catch {
        # Ignore notification errors
    }
}

function Get-LoggingStatistics {
    <#
    .SYNOPSIS
        Returns current logging statistics
    #>

    if (-not $global:sync.LoggingStats) {
        return @{
            TotalMessages = 0
            ErrorCount = 0
            WarningCount = 0
            Uptime = "0:00:00"
        }
    }

    $uptime = (Get-Date) - $global:sync.LoggingStats.StartTime

    return @{
        TotalMessages = $global:sync.LoggingStats.TotalMessages
        ErrorCount = $global:sync.LoggingStats.ErrorCount
        WarningCount = $global:sync.LoggingStats.WarningCount
        Uptime = $uptime.ToString("h\:mm\:ss")
        LogFile = $global:sync.logFile
        CurrentLevel = $global:sync.CurrentLogLevel
    }
}

function Export-LoggingReport {
    <#
    .SYNOPSIS
        Exports a comprehensive logging report
    #>

    param(
        [string]$OutputPath = "$env:USERPROFILE\Desktop\WDCA_LogReport_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt"
    )

    try {
        $stats = Get-LoggingStatistics
        $report = @"
WDCA Logging Report
Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
================================================================================

STATISTICS:
- Total Messages Logged: $($stats.TotalMessages)
- Errors: $($stats.ErrorCount)
- Warnings: $($stats.WarningCount)
- Session Uptime: $($stats.Uptime)
- Log File: $($stats.LogFile)
- Current Log Level: $($stats.CurrentLevel)

RECENT ERRORS:
"@

        if ($global:sync.ErrorLog -and $global:sync.ErrorLog.Count -gt 0) {
            foreach ($error in ($global:sync.ErrorLog | Select-Object -Last 10)) {
                $report += "`n[$($error.Timestamp.ToString('HH:mm:ss'))] $($error.Source): $($error.Message)"
            }
        } else {
            $report += "`nNo recent errors recorded."
        }

        $report += "`n`n================================================================================`n"

        Set-Content -Path $OutputPath -Value $report -Encoding UTF8
        Write-Logger "Logging report exported to: $OutputPath" "SUCCESS"

        return $OutputPath
    }
    catch {
        Write-Logger "Failed to export logging report: $($_.Exception.Message)" "ERROR"
        return $null
    }
}

# Alias for compatibility
function Set-WDCAStatus {
    <#
    .SYNOPSIS
        Updates the WDCA status bar - wrapper for Write-Logger
    #>

    param([string]$Status)

    if ($global:sync.WPFStatusText) {
        Update-StatusBarSafe -Message $Status
    }

    Write-Logger $Status "INFO" $false
}

# Aktualisierte Write-Progress-Logger.ps1 - ERSETZT die bestehende Datei

function Write-Progress-Logger {
    <#
    .SYNOPSIS
        Thread-sichere Progress-Logging Funktion

    .DESCRIPTION
        Ersetzt die alte Write-Progress-Logger Funktion mit thread-sicherem Design
    #>

    param(
        [Parameter(Mandatory = $true)]
        [string]$Message,
        [Parameter(Mandatory = $false)]
        [int]$PercentComplete = -1
    )

    # Use the new thread-safe function
    Update-ProgressSafe -Message $Message -PercentComplete $PercentComplete
}

function Add-DiagnosticResult {
    <#
    .SYNOPSIS
        Thread-sichere Diagnostic Results Funktion

    .DESCRIPTION
        Ersetzt die alte Add-DiagnosticResult Funktion mit thread-sicherem Design
    #>

    param([string]$Text)

    # Use the new thread-safe function
    Add-DiagnosticResultSafe -Text $Text
}

function Clear-DiagnosticResults {
    <#
    .SYNOPSIS
        Thread-sichere Clear Results Funktion
    #>

    try {
        if ($global:sync.WPFDiagnosticResults) {
            $global:sync.WPFDiagnosticResults.Dispatcher.Invoke([action]{
                $global:sync.WPFDiagnosticResults.Text = ""
            })
        }
    }
    catch {
        Write-Logger "Error clearing diagnostic results: $($_.Exception.Message)" "ERROR"
    }
}

# Runspace Pool Management
function Initialize-RunspacePool {
    <#
    .SYNOPSIS
        Initialisiert den Runspace Pool fÃ¼r bessere Performance
    #>

    if (-not $global:RunspacePool) {
        try {
            $global:RunspacePool = [runspacefactory]::CreateRunspacePool(1, 5)
            $global:RunspacePool.Open()
            Write-Logger "Runspace pool initialized with 1-5 threads" "INFO"
        }
        catch {
            Write-Logger "Error initializing runspace pool: $($_.Exception.Message)" "ERROR"
        }
    }
}

function Close-RunspacePool {
    <#
    .SYNOPSIS
        SchlieÃŸt den Runspace Pool beim Beenden
    #>

    if ($global:RunspacePool) {
        try {
            $global:RunspacePool.Close()
            $global:RunspacePool.Dispose()
            $global:RunspacePool = $null
            Write-Logger "Runspace pool closed" "INFO"
        }
        catch {
            Write-Logger "Error closing runspace pool: $($_.Exception.Message)" "ERROR"
        }
    }
}

# Job Management fÃ¼r langanhaltende Operationen
function Get-ActiveAsyncOperations {
    <#
    .SYNOPSIS
        Zeigt aktive async Operationen an
    #>

    if ($global:ActiveOperations) {
        return $global:ActiveOperations.Keys
    }
    return @()
}

function Stop-AllAsyncOperations {
    <#
    .SYNOPSIS
        Stoppt alle aktiven async Operationen
    #>

    if ($global:ActiveOperations) {
        foreach ($operationName in $global:ActiveOperations.Keys) {
            try {
                $operation = $global:ActiveOperations[$operationName]
                if ($operation.Timer) {
                    $operation.Timer.Stop()
                }
                if ($operation.PowerShell) {
                    $operation.PowerShell.Stop()
                    $operation.PowerShell.Dispose()
                }
                Write-Logger "Stopped async operation: $operationName" "INFO"
            }
            catch {
                Write-Logger "Error stopping operation $operationName`: $($_.Exception.Message)" "ERROR"
            }
        }
        $global:ActiveOperations.Clear()
    }

    # Re-enable UI
    Set-UIEnabled -Enabled $true
    Reset-ProgressBar
}

# Enhanced UI State Management
function Save-UIState {
    <#
    .SYNOPSIS
        Speichert den aktuellen UI-Status
    #>

    if (-not $global:UIStateStack) {
        $global:UIStateStack = @()
    }

    $currentState = @{
        ButtonStates = @{}
        ProgressVisible = $false
        StatusText = ""
    }

    # Save button states
    $buttonNames = @(
        "WPFInstallSelectedApps", "WPFSelectAllApps", "WPFDeselectAllApps",
        "WPFConfigureNetwork", "WPFEnableRDP", "WPFApplyRole",
        "WPFRunDiagnostics", "WPFRunDISM", "WPFRunSFC", "WPFRunCHKDSK", "WPFNetworkDiagnostics",
        "WPFCheckUpdates", "WPFInstallUpdates", "WPFUpdateApps", "WPFUpgradeApps",
        "WPFRunSysprep", "WPFRunCleanup", "WPFPrepareSysprep"
    )

    foreach ($buttonName in $buttonNames) {
        if ($global:sync[$buttonName]) {
            $currentState.ButtonStates[$buttonName] = $global:sync[$buttonName].IsEnabled
        }
    }

    # Save progress state
    if ($global:sync.WPFProgressBar) {
        $currentState.ProgressVisible = $global:sync.WPFProgressBar.Visibility -eq "Visible"
    }

    # Save status text
    if ($global:sync.WPFStatusText) {
        $currentState.StatusText = $global:sync.WPFStatusText.Text
    }

    $global:UIStateStack += $currentState
}

function Restore-UIState {
    <#
    .SYNOPSIS
        Stellt den gespeicherten UI-Status wieder her
    #>

    if ($global:UIStateStack -and $global:UIStateStack.Count -gt 0) {
        $lastState = $global:UIStateStack[$global:UIStateStack.Count - 1]
        $global:UIStateStack = $global:UIStateStack[0..($global:UIStateStack.Count - 2)]

        try {
            if ($global:sync.Form) {
                $global:sync.Form.Dispatcher.Invoke([action]{
                    # Restore button states
                    foreach ($buttonName in $lastState.ButtonStates.Keys) {
                        if ($global:sync[$buttonName]) {
                            $global:sync[$buttonName].IsEnabled = $lastState.ButtonStates[$buttonName]
                        }
                    }

                    # Restore progress state
                    if ($global:sync.WPFProgressBar) {
                        $global:sync.WPFProgressBar.Visibility = if ($lastState.ProgressVisible) { "Visible" } else { "Collapsed" }
                    }

                    # Restore status text
                    if ($global:sync.WPFStatusText -and $lastState.StatusText) {
                        $global:sync.WPFStatusText.Text = $lastState.StatusText
                    }
                })
            }
        }
        catch {
            Write-Logger "Error restoring UI state: $($_.Exception.Message)" "ERROR"
        }
    }
}

function Clear-EventLogs {
    <#
    .SYNOPSIS
        Clears Windows Event Logs

    .DESCRIPTION
        Clears all event logs to reduce system footprint for imaging
    #>

    try {
        $logs = Get-WinEvent -ListLog * -ErrorAction SilentlyContinue | Where-Object { $_.RecordCount -gt 0 }
        $clearedCount = 0

        foreach ($log in $logs) {
            try {
                [System.Diagnostics.Eventing.Reader.EventLogSession]::GlobalSession.ClearLog($log.LogName)
                $clearedCount++
            }
            catch {
                # Some logs cannot be cleared, continue with others
            }
        }

        Write-Logger "Cleared $clearedCount event logs" "INFO"
        return "$clearedCount logs cleared"
    }
    catch {
        Write-Logger "Error clearing event logs: $($_.Exception.Message)" "WARNING"
        return "Error clearing logs"
    }
}


function Clear-RecycleBin {
    <#
    .SYNOPSIS
        Empties the Recycle Bin

    .DESCRIPTION
        Clears all files from the Recycle Bin to free up space
    #>

    try {
        # Use PowerShell 5.0+ cmdlet if available
        if (Get-Command Clear-RecycleBin -ErrorAction SilentlyContinue) {
            Clear-RecycleBin -Force -ErrorAction Stop
            Write-Logger "Recycle bin emptied using Clear-RecycleBin" "INFO"
            return "Recycle bin emptied"
        }
        else {
            # Fallback method
            $recycleBin = (New-Object -ComObject Shell.Application).Namespace(0xA)
            $recycleBin.Items() | ForEach-Object { Remove-Item $_.Path -Recurse -Force -ErrorAction SilentlyContinue }
            Write-Logger "Recycle bin emptied using fallback method" "INFO"
            return "Recycle bin emptied"
        }
    }
    catch {
        Write-Logger "Error emptying recycle bin: $($_.Exception.Message)" "WARNING"
        return "Error emptying recycle bin"
    }
}

function Clear-TemporaryFiles {
    <#
    .SYNOPSIS
        Clears temporary files from various locations with improved error handling
    #>

    $totalCleaned = 0
    $locations = @(
        @{Path = "$env:TEMP"; Name = "User Temp"},
        @{Path = "$env:SystemRoot\Temp"; Name = "System Temp"},
        @{Path = "$env:LocalAppData\Temp"; Name = "Local AppData Temp"}
    )

    foreach ($location in $locations) {
        if (-not (Test-Path $location.Path)) {
            Write-Logger "Location not found: $($location.Path)" "WARNING"
            continue
        }

        try {
            $sizeBefore = 0
            $files = Get-ChildItem -Path $location.Path -Recurse -File -ErrorAction SilentlyContinue
            if ($files) {
                $sizeBefore = ($files | Measure-Object -Property Length -Sum).Sum
            }

            # Remove files with better error handling
            $removed = 0
            foreach ($file in $files) {
                try {
                    Remove-Item -Path $file.FullName -Force -ErrorAction Stop
                    $removed++
                }
                catch {
                    Write-Logger "Could not remove file: $($file.FullName) - $($_.Exception.Message)" "DEBUG"
                }
            }

            $sizeAfter = 0
            $remainingFiles = Get-ChildItem -Path $location.Path -Recurse -File -ErrorAction SilentlyContinue
            if ($remainingFiles) {
                $sizeAfter = ($remainingFiles | Measure-Object -Property Length -Sum).Sum
            }

            $cleaned = $sizeBefore - $sizeAfter
            $totalCleaned += $cleaned

            Write-Logger "Cleaned $($location.Name) - Removed $removed files, Freed $([math]::Round($cleaned / 1MB, 2)) MB" "INFO"
        }
        catch {
            Write-Logger "Error cleaning $($location.Name): $($_.Exception.Message)" "ERROR"
        }
    }

    return "$([math]::Round($totalCleaned / 1MB, 2)) MB cleaned"
}

function Convert-SubnetMaskToPrefixLength {
    param([string]$SubnetMask)
    try {
        $mask = [System.Net.IPAddress]::Parse($SubnetMask)
        $bytes = $mask.GetAddressBytes()
        $binaryString = ""

        # Convert all bytes to binary string
        foreach ($byte in $bytes) {
            $binaryString += [Convert]::ToString($byte, 2).PadLeft(8, '0')
        }

        # Count consecutive 1s from the left
        $prefixLength = 0
        for ($i = 0; $i -lt $binaryString.Length; $i++) {
            if ($binaryString[$i] -eq '1') {
                $prefixLength++
            } else {
                break
            }
        }

        # Validate that all remaining bits are 0
        $remainingBits = $binaryString.Substring($prefixLength)
        if ($remainingBits -match '1') {
            throw "Invalid subnet mask - non-contiguous bits"
        }

        return $prefixLength
    }
    catch {
        Write-Logger "Error converting subnet mask '$SubnetMask': $($_.Exception.Message)" "WARNING"
        return 24  # Default to /24
    }
}

function Invoke-CHKDSKScan {
    <#
    .SYNOPSIS
        Runs CHKDSK disk check in a new terminal with real-time output
    .DESCRIPTION
        Creates a simple PowerShell script that runs CHKDSK on the system drive
        with real-time progress display and detailed results.
    #>

    Write-Logger "Starting CHKDSK scan in new terminal" "INFO"

    $tempScriptPath = Join-Path $env:TEMP "WDCA_CHKDSK_Scan.ps1"
    $logPath = Join-Path $env:TEMP "wdca_chkdsk.log"
    $systemDrive = $env:SystemDrive

    $scriptContent = @"
# Terminal styling
`$Host.UI.RawUI.BackgroundColor = "Black"
`$Host.UI.RawUI.ForegroundColor = "White"
Clear-Host

# Simple logging function
function Write-CHKDSKLog {
    param([string]`$Message, [string]`$Level = "INFO")
    try {
        `$timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        Add-Content -Path "$logPath" -Value "[`$timestamp] [`$Level] `$Message" -Encoding UTF8 -ErrorAction SilentlyContinue
    } catch { }
}

# Header
Write-Host ("=" * 50) -ForegroundColor Cyan
Write-Host "  WDCA CHKDSK Disk Check Tool" -ForegroundColor Cyan
Write-Host ("=" * 50) -ForegroundColor Cyan
Write-Host ""

Write-CHKDSKLog "CHKDSK scan started on drive $systemDrive" "INFO"
Write-Host "[INFO] Starting CHKDSK on system drive: $systemDrive" -ForegroundColor Cyan
Write-Host "[INFO] This will check and repair disk errors" -ForegroundColor Cyan
Write-Host ""

try {
    `$stopwatch = [System.Diagnostics.Stopwatch]::StartNew()

    # Check if drive is in use (system drive scenario)
    Write-Host "Checking drive accessibility..." -ForegroundColor Yellow
    Write-CHKDSKLog "Checking if drive $systemDrive is accessible for repair" "INFO"

    # Run CHKDSK with /f (fix) and /r (recover) flags
    Write-Host ""
    Write-Host "CHKDSK Output:" -ForegroundColor Yellow
    Write-Host ("-" * 30) -ForegroundColor DarkGray
    Write-CHKDSKLog "Running: chkdsk $systemDrive /f /r" "INFO"

    `$chkdskProcess = Start-Process -FilePath "chkdsk.exe" -ArgumentList "$systemDrive", "/f", "/r" -Wait -PassThru -NoNewWindow

    `$stopwatch.Stop()
    `$duration = `$stopwatch.Elapsed.ToString("mm\:ss")

    Write-Host ""
    Write-Host ("-" * 30) -ForegroundColor DarkGray

    # Analyze results based on exit code
    switch (`$chkdskProcess.ExitCode) {
        0 {
            Write-Host "[SUCCESS] CHKDSK completed successfully - No errors found (Duration: `$duration)" -ForegroundColor Green
            Write-CHKDSKLog "CHKDSK completed successfully in `$duration" "SUCCESS"
        }
        1 {
            Write-Host "[SUCCESS] CHKDSK found and fixed errors (Duration: `$duration)" -ForegroundColor Green
            Write-CHKDSKLog "CHKDSK found and fixed errors in `$duration" "SUCCESS"
        }
        2 {
            Write-Host "[SCHEDULED] CHKDSK scheduled for next reboot (Duration: `$duration)" -ForegroundColor Yellow
            Write-Host "  System drive is currently in use - restart required" -ForegroundColor Yellow
            Write-CHKDSKLog "CHKDSK scheduled for next reboot (drive in use)" "INFO"
        }
        3 {
            Write-Host "[WARNING] CHKDSK could not run - Drive may be locked (Duration: `$duration)" -ForegroundColor Yellow
            Write-CHKDSKLog "CHKDSK could not run, drive locked (Duration: `$duration)" "WARNING"
        }
        default {
            Write-Host "[WARNING] CHKDSK completed with exit code `$(`$chkdskProcess.ExitCode) (Duration: `$duration)" -ForegroundColor Yellow
            Write-CHKDSKLog "CHKDSK completed with exit code `$(`$chkdskProcess.ExitCode) (Duration: `$duration)" "WARNING"
        }
    }

    # Additional disk information
    Write-Host ""
    Write-Host "Drive Information:" -ForegroundColor DarkCyan
    try {
        `$driveInfo = Get-WmiObject -Class Win32_LogicalDisk -Filter "DeviceID='$systemDrive'" -ErrorAction Stop
        `$totalSize = [math]::Round(`$driveInfo.Size / 1GB, 2)
        `$freeSpace = [math]::Round(`$driveInfo.FreeSpace / 1GB, 2)
        `$usedSpace = `$totalSize - `$freeSpace
        `$freePercent = [math]::Round((`$freeSpace / `$totalSize) * 100, 1)

        Write-Host "  Drive: $systemDrive (`$(`$driveInfo.VolumeName))" -ForegroundColor Gray
        Write-Host "  Total Size: `$totalSize GB" -ForegroundColor Gray
        Write-Host "  Used Space: `$usedSpace GB" -ForegroundColor Gray
        Write-Host "  Free Space: `$freeSpace GB (`$freePercent%)" -ForegroundColor Gray
        Write-Host "  File System: `$(`$driveInfo.FileSystem)" -ForegroundColor Gray

        Write-CHKDSKLog "Drive info: `$totalSize GB total, `$freeSpace GB free (`$freePercent%)" "INFO"

        if (`$freePercent -lt 10) {
            Write-Host "  [WARNING] Low disk space detected!" -ForegroundColor Red
            Write-CHKDSKLog "Low disk space warning: only `$freePercent% free" "WARNING"
        }
    }
    catch {
        Write-Host "  Could not retrieve drive information" -ForegroundColor Yellow
        Write-CHKDSKLog "Failed to get drive information: `$(`$_.Exception.Message)" "WARNING"
    }

    # Status summary and recommendations
    Write-Host ""
    if (`$chkdskProcess.ExitCode -eq 0) {
        Write-Host "Status: Disk is healthy - no errors found" -ForegroundColor Green
    } elseif (`$chkdskProcess.ExitCode -eq 1) {
        Write-Host "Status: Disk errors found and repaired" -ForegroundColor Green
    } elseif (`$chkdskProcess.ExitCode -eq 2) {
        Write-Host "Status: CHKDSK will run on next restart" -ForegroundColor Yellow
        Write-Host "Action: Please restart your computer to complete the disk check" -ForegroundColor Cyan
    } else {
        Write-Host "Status: Check completed with warnings" -ForegroundColor Yellow
        Write-Host "Tip: Try running as Administrator for full disk access" -ForegroundColor Cyan
    }

}
catch {
    Write-Host "[ERROR] Failed to run CHKDSK: `$(`$_.Exception.Message)" -ForegroundColor Red
    Write-CHKDSKLog "CHKDSK error: `$(`$_.Exception.Message)" "ERROR"
}

# Footer
Write-Host ""
Write-Host ("-" * 50) -ForegroundColor DarkGray
Write-Host "Log saved to: $logPath" -ForegroundColor Cyan
Write-CHKDSKLog "CHKDSK scan completed" "INFO"

Write-Host ""
Write-Host "Press any key to close..." -ForegroundColor Blue
`$null = `$Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
"@

    # Create and run script
    try {
        Set-Content -Path $tempScriptPath -Value $scriptContent -Encoding UTF8
        Write-Logger "Created CHKDSK script: $tempScriptPath" "INFO"

        $chkdskProcess = Start-Process -FilePath "powershell.exe" -ArgumentList @(
            "-NoProfile"
            "-ExecutionPolicy", "Bypass"
            "-File", "`"$tempScriptPath`""
        ) -WindowStyle Normal -PassThru

        Write-Logger "Started CHKDSK terminal (PID: $($chkdskProcess.Id))" "SUCCESS"

        # Cleanup script after use
        Start-Job -ScriptBlock {
            param($ProcessId, $ScriptPath)
            try {
                $process = Get-Process -Id $ProcessId -ErrorAction SilentlyContinue
                if ($process) { $process.WaitForExit() }
                Start-Sleep -Seconds 5
                if (Test-Path $ScriptPath) {
                    Remove-Item $ScriptPath -Force -ErrorAction SilentlyContinue
                }
            } catch { }
        } -ArgumentList $chkdskProcess.Id, $tempScriptPath | Out-Null

    }
    catch {
        Write-Logger "Failed to start CHKDSK: $($_.Exception.Message)" "ERROR"
        [System.Windows.MessageBox]::Show(
            "Failed to start CHKDSK scan.`n$($_.Exception.Message)",
            "WDCA - CHKDSK Error",
            [System.Windows.MessageBoxButton]::OK,
            [System.Windows.MessageBoxImage]::Error
        )

        if (Test-Path $tempScriptPath) {
            Remove-Item $tempScriptPath -Force -ErrorAction SilentlyContinue
        }
    }
}

function Invoke-DiskCleanup {
    <#
    .SYNOPSIS
        Runs Windows Disk Cleanup utility

    .DESCRIPTION
        Executes cleanmgr.exe to perform additional system cleanup
    #>

    try {
        # Run disk cleanup with preset options
        $cleanmgrArgs = @("/sagerun:0001")

        # Set cleanup options in registry first
        $regPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VolumeCaches"
        $cleanupItems = @(
            "Downloaded Program Files",
            "Internet Cache Files",
            "System error memory dump files",
            "System error minidump files",
            "D3D Shader Cache",
            "Delivery Optimization Files",
            "Temporary Files",
            "Thumbnail Cache"
        )

        foreach ($item in $cleanupItems) {
            $itemPath = Join-Path $regPath $item
            if (Test-Path $itemPath) {
                Set-ItemProperty -Path $itemPath -Name "StateFlags0001" -Value 2 -ErrorAction SilentlyContinue
            }
        }

        # Run cleanup
        Start-Process -FilePath "cleanmgr.exe" -ArgumentList $cleanmgrArgs -Wait -NoNewWindow -ErrorAction SilentlyContinue

        Write-Logger "Disk cleanup completed" "INFO"
    }
    catch {
        Write-Logger "Error running disk cleanup: $($_.Exception.Message)" "WARNING"
    }
}

function Invoke-DISMScan {
    <#
    .SYNOPSIS
        Runs DISM image repair commands in a new terminal with real-time output
    .DESCRIPTION
        Creates a simple PowerShell script that runs DISM CheckHealth, ScanHealth,
        and RestoreHealth commands in sequence with real-time progress display.
    #>

    Write-Logger "Starting DISM scan in new terminal" "INFO"

    $tempScriptPath = Join-Path $env:TEMP "WDCA_DISM_Scan.ps1"
    $logPath = Join-Path $env:TEMP "wdca_dism.log"

    $scriptContent = @"
# Terminal styling
`$Host.UI.RawUI.BackgroundColor = "Black"
`$Host.UI.RawUI.ForegroundColor = "White"
Clear-Host

# Simple logging function
function Write-DISMLog {
    param([string]`$Message, [string]`$Level = "INFO")
    try {
        `$timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        Add-Content -Path "$logPath" -Value "[`$timestamp] [`$Level] `$Message" -Encoding UTF8 -ErrorAction SilentlyContinue
    } catch { }
}

# Header
Write-Host ("=" * 50) -ForegroundColor Cyan
Write-Host "  WDCA DISM Image Repair Tool" -ForegroundColor Cyan
Write-Host ("=" * 50) -ForegroundColor Cyan
Write-Host ""

Write-DISMLog "DISM repair session started" "INFO"
Write-Host "[INFO] Starting DISM image diagnostics and repair..." -ForegroundColor Cyan
Write-Host "[INFO] This process will run three sequential scans" -ForegroundColor Cyan
Write-Host ""

try {
    `$overallStopwatch = [System.Diagnostics.Stopwatch]::StartNew()

    # Step 1: CheckHealth (Quick check)
    Write-Host "Step 1/3: Quick Health Check" -ForegroundColor Yellow
    Write-Host ("-" * 30) -ForegroundColor DarkGray
    Write-DISMLog "Running: DISM /Online /Cleanup-Image /CheckHealth" "INFO"

    `$checkStopwatch = [System.Diagnostics.Stopwatch]::StartNew()
    `$checkProcess = Start-Process -FilePath "dism.exe" -ArgumentList "/Online", "/Cleanup-Image", "/CheckHealth" -Wait -PassThru -NoNewWindow
    `$checkStopwatch.Stop()

    if (`$checkProcess.ExitCode -eq 0) {
        Write-Host "[SUCCESS] CheckHealth completed (`$(`$checkStopwatch.Elapsed.ToString("mm\:ss")))" -ForegroundColor Green
        Write-DISMLog "CheckHealth completed successfully" "SUCCESS"
    } else {
        Write-Host "[WARNING] CheckHealth completed with issues (Exit: `$(`$checkProcess.ExitCode))" -ForegroundColor Yellow
        Write-DISMLog "CheckHealth completed with exit code `$(`$checkProcess.ExitCode)" "WARNING"
    }

    Write-Host ""

    # Step 2: ScanHealth (Detailed scan)
    Write-Host "Step 2/3: Detailed Health Scan" -ForegroundColor Yellow
    Write-Host ("-" * 30) -ForegroundColor DarkGray
    Write-DISMLog "Running: DISM /Online /Cleanup-Image /ScanHealth" "INFO"

    `$scanStopwatch = [System.Diagnostics.Stopwatch]::StartNew()
    `$scanProcess = Start-Process -FilePath "dism.exe" -ArgumentList "/Online", "/Cleanup-Image", "/ScanHealth" -Wait -PassThru -NoNewWindow
    `$scanStopwatch.Stop()

    if (`$scanProcess.ExitCode -eq 0) {
        Write-Host "[SUCCESS] ScanHealth completed (`$(`$scanStopwatch.Elapsed.ToString("mm\:ss")))" -ForegroundColor Green
        Write-DISMLog "ScanHealth completed successfully" "SUCCESS"
    } else {
        Write-Host "[WARNING] ScanHealth detected issues (Exit: `$(`$scanProcess.ExitCode))" -ForegroundColor Yellow
        Write-DISMLog "ScanHealth detected issues with exit code `$(`$scanProcess.ExitCode)" "WARNING"
    }

    Write-Host ""

    # Step 3: RestoreHealth (Repair if needed)
    Write-Host "Step 3/3: Image Repair" -ForegroundColor Yellow
    Write-Host ("-" * 30) -ForegroundColor DarkGray
    Write-DISMLog "Running: DISM /Online /Cleanup-Image /RestoreHealth" "INFO"

    `$repairStopwatch = [System.Diagnostics.Stopwatch]::StartNew()
    `$repairProcess = Start-Process -FilePath "dism.exe" -ArgumentList "/Online", "/Cleanup-Image", "/RestoreHealth" -Wait -PassThru -NoNewWindow
    `$repairStopwatch.Stop()

    if (`$repairProcess.ExitCode -eq 0) {
        Write-Host "[SUCCESS] RestoreHealth completed (`$(`$repairStopwatch.Elapsed.ToString("mm\:ss")))" -ForegroundColor Green
        Write-DISMLog "RestoreHealth completed successfully" "SUCCESS"
    } else {
        Write-Host "[WARNING] RestoreHealth completed with issues (Exit: `$(`$repairProcess.ExitCode))" -ForegroundColor Yellow
        Write-DISMLog "RestoreHealth completed with exit code `$(`$repairProcess.ExitCode)" "WARNING"
    }

    `$overallStopwatch.Stop()

    # Results summary
    Write-Host ""
    Write-Host ("-" * 50) -ForegroundColor DarkGray
    Write-Host "DISM Repair Summary:" -ForegroundColor Cyan
    Write-Host "  CheckHealth:   Exit Code `$(`$checkProcess.ExitCode)" -ForegroundColor Gray
    Write-Host "  ScanHealth:    Exit Code `$(`$scanProcess.ExitCode)" -ForegroundColor Gray
    Write-Host "  RestoreHealth: Exit Code `$(`$repairProcess.ExitCode)" -ForegroundColor Gray
    Write-Host "  Total Duration: `$(`$overallStopwatch.Elapsed.ToString("mm\:ss"))" -ForegroundColor Gray

    # Overall status assessment
    Write-Host ""
    if (`$checkProcess.ExitCode -eq 0 -and `$scanProcess.ExitCode -eq 0 -and `$repairProcess.ExitCode -eq 0) {
        Write-Host "Status: Windows image is healthy" -ForegroundColor Green
        Write-DISMLog "All DISM operations completed successfully" "SUCCESS"
    } elseif (`$repairProcess.ExitCode -eq 0) {
        Write-Host "Status: Issues found and repaired successfully" -ForegroundColor Green
        Write-DISMLog "DISM found and repaired image issues" "SUCCESS"
    } else {
        Write-Host "Status: Some issues may require additional attention" -ForegroundColor Yellow
        Write-DISMLog "DISM completed with potential remaining issues" "WARNING"
        Write-Host "Tip: Consider running SFC /scannow after DISM repair" -ForegroundColor Cyan
    }

}
catch {
    Write-Host "[ERROR] DISM operation failed: `$(`$_.Exception.Message)" -ForegroundColor Red
    Write-DISMLog "DISM error: `$(`$_.Exception.Message)" "ERROR"
}

# Footer
Write-Host ""
Write-Host ("-" * 50) -ForegroundColor DarkGray
Write-Host "Log saved to: $logPath" -ForegroundColor Cyan
Write-DISMLog "DISM repair session completed" "INFO"

Write-Host ""
Write-Host "Press any key to close..." -ForegroundColor Blue
`$null = `$Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
"@

    # Create and run script
    try {
        Set-Content -Path $tempScriptPath -Value $scriptContent -Encoding UTF8
        Write-Logger "Created DISM script: $tempScriptPath" "INFO"

        $dismProcess = Start-Process -FilePath "powershell.exe" -ArgumentList @(
            "-NoProfile"
            "-ExecutionPolicy", "Bypass"
            "-File", "`"$tempScriptPath`""
        ) -WindowStyle Normal -PassThru

        Write-Logger "Started DISM terminal (PID: $($dismProcess.Id))" "SUCCESS"

        # Cleanup script after use
        Start-Job -ScriptBlock {
            param($ProcessId, $ScriptPath)
            try {
                $process = Get-Process -Id $ProcessId -ErrorAction SilentlyContinue
                if ($process) { $process.WaitForExit() }
                Start-Sleep -Seconds 5
                if (Test-Path $ScriptPath) {
                    Remove-Item $ScriptPath -Force -ErrorAction SilentlyContinue
                }
            } catch { }
        } -ArgumentList $dismProcess.Id, $tempScriptPath | Out-Null

    }
    catch {
        Write-Logger "Failed to start DISM: $($_.Exception.Message)" "ERROR"
        [System.Windows.MessageBox]::Show(
            "Failed to start DISM scan.`n$($_.Exception.Message)",
            "WDCA - DISM Error",
            [System.Windows.MessageBoxButton]::OK,
            [System.Windows.MessageBoxImage]::Error
        )

        if (Test-Path $tempScriptPath) {
            Remove-Item $tempScriptPath -Force -ErrorAction SilentlyContinue
        }
    }
}

function Invoke-DomainControllerUpgradePrep {
    <#
    .SYNOPSIS
        Prepares Active Directory Domain Controller for Windows In-Place Upgrade

    .DESCRIPTION
        Comprehensive preparation for DC in-place upgrade including Forest Prep, Domain Prep,
        FSMO role analysis, replication health, and AD-specific readiness checks.

    .PARAMETER TargetWindowsVersion
        Target Windows Server version for upgrade

    .PARAMETER PerformForestPrep
        Whether to perform Forest Prep operations

    .PARAMETER PerformDomainPrep
        Whether to perform Domain Prep operations

    .EXAMPLE
        Invoke-DomainControllerUpgradePrep -TargetWindowsVersion "2022"
        Invoke-DomainControllerUpgradePrep -PerformForestPrep -PerformDomainPrep
    #>

    param(
        [Parameter(Mandatory = $false)]
        [ValidateSet("2019", "2022", "2025")]
        [string]$TargetWindowsVersion = "2022",

        [Parameter(Mandatory = $false)]
        [switch]$PerformForestPrep,

        [Parameter(Mandatory = $false)]
        [switch]$PerformDomainPrep
    )

    Write-Logger "Starting Domain Controller Upgrade Preparation for Windows Server $TargetWindowsVersion" "INFO"

    try {
        # Confirmation dialog with DC-specific warnings
        $confirmMessage = @"
Prepare Domain Controller for Windows Server $TargetWindowsVersion In-Place Upgrade?

  CRITICAL WARNINGS:
- Domain Controller upgrade affects entire AD environment
- Forest/Domain Prep may be required
- FSMO role holders need special consideration
- Replication must be healthy before upgrade
- Extended downtime expected

Continue with DC upgrade preparation?
"@

        $confirmResult = [System.Windows.MessageBox]::Show(
            $confirmMessage,
            "WDCA - Domain Controller Upgrade Preparation",
            [System.Windows.MessageBoxButton]::YesNo,
            [System.Windows.MessageBoxImage]::Warning
        )

        if ($confirmResult -ne [System.Windows.MessageBoxResult]::Yes) {
            Write-Logger "DC upgrade preparation cancelled by user" "INFO"
            return
        }

        # Main DC upgrade preparation script
        $dcUpgradeScript = {
            param($targetVersion, $forestPrep, $domainPrep)

            $results = @()
            $warnings = @()
            $errors = @()
            $recommendations = @()
            $forestPrepRequired = $false
            $domainPrepRequired = $false

            try {
                $results += "=== DOMAIN CONTROLLER UPGRADE PREPARATION ==="
                $results += "Target Windows Version: Server $targetVersion"
                $results += "Started: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
                $results += ""

                # Import AD Module
                $results += "=== Active Directory Module Check ==="
                try {
                    Import-Module ActiveDirectory -ErrorAction Stop
                    $results += "AD PowerShell Module: LOADED"
                } catch {
                    $errors += "Active Directory PowerShell module not available"
                    $results += "AD PowerShell Module: FAILED TO LOAD"
                    $results += "Install RSAT-AD-PowerShell feature or AD management tools"
                    throw "Cannot proceed without AD PowerShell module"
                }
                $results += ""

                # Current DC Information
                $results += "=== DOMAIN CONTROLLER ANALYSIS ==="
                $computer = Get-ADComputer -Identity $env:COMPUTERNAME -Properties OperatingSystem, OperatingSystemVersion
                $domain = Get-ADDomain
                $forest = Get-ADForest

                $results += "Current DC: $($computer.Name)"
                $results += "Current OS: $($computer.OperatingSystem) $($computer.OperatingSystemVersion)"
                $results += "Domain: $($domain.DNSRoot)"
                $results += "Forest: $($forest.Name)"
                $results += "Domain Functional Level: $($domain.DomainMode)"
                $results += "Forest Functional Level: $($forest.ForestMode)"
                $results += ""

                # FSMO Roles Analysis
                $results += "=== FSMO ROLES ANALYSIS ==="
                $forestFSMO = @{
                    'Schema Master' = $forest.SchemaMaster
                    'Domain Naming Master' = $forest.DomainNamingMaster
                }

                $domainFSMO = @{
                    'PDC Emulator' = $domain.PDCEmulator
                    'RID Master' = $domain.RIDMaster
                    'Infrastructure Master' = $domain.InfrastructureMaster
                }

                $currentDC = "$($env:COMPUTERNAME).$($domain.DNSRoot)"
                $fsmoRoles = @()

                foreach ($role in $forestFSMO.GetEnumerator()) {
                    $results += "$($role.Key): $($role.Value)"
                    if ($role.Value -eq $currentDC) {
                        $fsmoRoles += $role.Key
                        $warnings += "This DC holds Forest-wide FSMO role: $($role.Key)"
                    }
                }

                foreach ($role in $domainFSMO.GetEnumerator()) {
                    $results += "$($role.Key): $($role.Value)"
                    if ($role.Value -eq $currentDC) {
                        $fsmoRoles += $role.Key
                        $warnings += "This DC holds Domain FSMO role: $($role.Key)"
                    }
                }

                if ($fsmoRoles.Count -gt 0) {
                    $results += ""
                    $results += "THIS DC HOLDS $($fsmoRoles.Count) FSMO ROLE(S):"
                    foreach ($role in $fsmoRoles) {
                        $results += "   - $role"
                    }
                    $recommendations += "Consider transferring FSMO roles to another DC before upgrade"
                    $recommendations += "Document FSMO role transfer procedures"
                } else {
                    $results += "This DC holds no FSMO roles - safer for upgrade"
                }
                $results += ""

                # Forest/Domain Functional Level Check
                $results += "=== FUNCTIONAL LEVEL COMPATIBILITY ==="

                # Windows Server version to functional level mapping
                $versionMapping = @{
                    "2019" = @{ Forest = "Windows2016Forest"; Domain = "Windows2016Domain"; MinFL = "2016" }
                    "2022" = @{ Forest = "Windows2016Forest"; Domain = "Windows2016Domain"; MinFL = "2016" }
                    "2025" = @{ Forest = "Windows2016Forest"; Domain = "Windows2016Domain"; MinFL = "2016" }
                }

                $targetMapping = $versionMapping[$targetVersion]
                $currentForestFL = $forest.ForestMode.ToString()
                $currentDomainFL = $domain.DomainMode.ToString()

                $results += "Current Forest FL: $currentForestFL"
                $results += "Current Domain FL: $currentDomainFL"
                $results += "Required for Server $targetVersion`: $($targetMapping.MinFL) or higher"

                # Check if Forest Prep is needed
                if ($currentForestFL -lt $targetMapping.Forest) {
                    $forestPrepRequired = $true
                    $warnings += "Forest Prep required: Current FL ($currentForestFL) < Required FL"
                    $recommendations += "Run adprep /forestprep before any DC upgrade in forest"
                } else {
                    $results += "Forest functional level compatible"
                }

                # Check if Domain Prep is needed
                if ($currentDomainFL -lt $targetMapping.Domain) {
                    $domainPrepRequired = $true
                    $warnings += "Domain Prep required: Current FL ($currentDomainFL) < Required FL"
                    $recommendations += "Run adprep /domainprep in each domain"
                } else {
                    $results += "Domain functional level compatible"
                }
                $results += ""

                # AD Replication Health
                $results += "=== REPLICATION HEALTH CHECK ==="
                try {
                    # Check replication partners
                    $replPartners = Get-ADReplicationPartnerMetadata -Target $env:COMPUTERNAME -ErrorAction Stop
                    $results += "Replication Partners: $($replPartners.Count)"

                    $replErrors = 0
                    foreach ($partner in $replPartners) {
                        if ($partner.LastReplicationResult -ne 0) {
                            $replErrors++
                            $errors += "Replication error with $($partner.Partner): Error $($partner.LastReplicationResult)"
                        }
                    }

                    if ($replErrors -eq 0) {
                        $results += "All replication partners healthy"
                    } else {
                        $results += "$replErrors replication errors found"
                        $recommendations += "Fix all replication errors before upgrade"
                    }

                    # Check replication failures
                    $replFailures = Get-ADReplicationFailure -Target $env:COMPUTERNAME -ErrorAction SilentlyContinue
                    if ($replFailures) {
                        $results += "Replication Failures: $($replFailures.Count)"
                        $errors += "Active replication failures detected"
                        $recommendations += "Resolve replication failures: repadmin /showrepl"
                    } else {
                        $results += "No replication failures"
                    }

                } catch {
                    $warnings += "Could not check replication health: $($_.Exception.Message)"
                    $recommendations += "Manually verify replication: repadmin /replsummary"
                }
                $results += ""

                # SYSVOL Health
                $results += "=== SYSVOL HEALTH CHECK ==="
                try {
                    $sysvol = "$env:SystemRoot\SYSVOL"
                    if (Test-Path $sysvol) {
                        $sysvolSize = (Get-ChildItem $sysvol -Recurse -File | Measure-Object -Property Length -Sum).Sum
                        $sysvolSizeGB = [math]::Round($sysvolSize / 1GB, 2)
                        $results += "SYSVOL Path: $sysvol"
                        $results += "SYSVOL Size: $sysvolSizeGB GB"

                        # Check DFSR vs FRS
                        $dfsrService = Get-Service -Name DFSR -ErrorAction SilentlyContinue
                        $ntfrsService = Get-Service -Name NtFrs -ErrorAction SilentlyContinue

                        if ($dfsrService -and $dfsrService.Status -eq "Running") {
                            $results += "SYSVOL Replication: DFSR (recommended)"
                        } elseif ($ntfrsService -and $ntfrsService.Status -eq "Running") {
                            $warnings += "SYSVOL using legacy FRS replication"
                            $recommendations += "Consider migrating to DFSR before upgrade"
                            $results += "SYSVOL Replication: FRS (legacy)"
                        }
                    } else {
                        $errors += "SYSVOL path not found: $sysvol"
                    }
                } catch {
                    $warnings += "Could not check SYSVOL health: $($_.Exception.Message)"
                }
                $results += ""

                # Directory Services Storage
                $results += "=== ACTIVE DIRECTORY DATABASE ==="
                try {
                    # Get NTDS database path
                    $ntdsPath = (Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\NTDS\Parameters" -Name "DSA Database file").('DSA Database file')
                    $logPath = (Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\NTDS\Parameters" -Name "Database log files path").('Database log files path')

                    $results += "NTDS Database: $ntdsPath"
                    $results += "NTDS Logs: $logPath"

                    if (Test-Path $ntdsPath) {
                        $dbSize = (Get-Item $ntdsPath).Length
                        $dbSizeGB = [math]::Round($dbSize / 1GB, 2)
                        $results += "Database Size: $dbSizeGB GB"

                        # Check available space on DB drive
                        $dbDrive = (Split-Path $ntdsPath -Qualifier)
                        $driveInfo = Get-WmiObject -Class Win32_LogicalDisk | Where-Object { $_.DeviceID -eq $dbDrive }
                        $freeSpaceGB = [math]::Round($driveInfo.FreeSpace / 1GB, 2)

                        $results += "Available Space on $dbDrive`: $freeSpaceGB GB"

                        if ($freeSpaceGB -lt ($dbSizeGB * 2)) {
                            $warnings += "Low disk space for AD database operations"
                            $recommendations += "Ensure at least double DB size free space for upgrade"
                        }
                    }
                } catch {
                    $warnings += "Could not analyze AD database: $($_.Exception.Message)"
                }
                $results += ""

                # DNS Configuration
                $results += "=== DNS CONFIGURATION ==="
                try {
                    $dnsService = Get-Service -Name DNS -ErrorAction SilentlyContinue
                    if ($dnsService) {
                        $results += "DNS Service: $($dnsService.Status)"

                        # Check if this DC is also a DNS server
                        if ($dnsService.Status -eq "Running") {
                            $results += "This DC is also a DNS server"

                            # Check DNS zones
                            $dnsZones = Get-DnsServerZone -ErrorAction SilentlyContinue
                            if ($dnsZones) {
                                $adIntegratedZones = $dnsZones | Where-Object { $_.ZoneType -eq "Primary" -and $_.IsDsIntegrated }
                                $results += "AD-Integrated DNS Zones: $($adIntegratedZones.Count)"
                                $recommendations += "Verify DNS zone replication after upgrade"
                            }
                        }
                    } else {
                        $results += "DNS Service: Not installed on this DC"
                        $warnings += "External DNS server must support SRV records for AD"
                    }
                } catch {
                    $warnings += "Could not check DNS configuration: $($_.Exception.Message)"
                }
                $results += ""

                # Global Catalog Status
                $results += "=== GLOBAL CATALOG STATUS ==="
                try {
                    $gcStatus = Get-ADDomainController -Identity $env:COMPUTERNAME | Select-Object IsGlobalCatalog
                    if ($gcStatus.IsGlobalCatalog) {
                        $results += "This DC is a Global Catalog server"
                        $warnings += "GC server upgrade may affect cross-domain authentication"
                        $recommendations += "Ensure other GC servers are available during upgrade"
                    } else {
                        $results += "This DC is not a Global Catalog server"
                    }
                } catch {
                    $warnings += "Could not check Global Catalog status: $($_.Exception.Message)"
                }
                $results += ""

                # ADPREP Requirements
                $results += "=== ADPREP PREPARATION REQUIREMENTS ==="

                if ($forestPrepRequired -or $forestPrep) {
                    $results += "FOREST PREP REQUIRED:"
                    $results += "1. Must be run on Schema Master: $($forest.SchemaMaster)"
                    $results += "2. User must be member of Schema Admins and Enterprise Admins"
                    $results += "3. Command: adprep /forestprep"
                    $results += "4. Location: Server $targetVersion installation media \\support\\adprep\\"
                    $recommendations += "Run Forest Prep on Schema Master before any DC upgrade"
                    $recommendations += "Verify Schema Admins and Enterprise Admins group membership"
                }

                if ($domainPrepRequired -or $domainPrep) {
                    $results += "DOMAIN PREP REQUIRED:"
                    $results += "1. Must be run on Infrastructure Master: $($domain.InfrastructureMaster)"
                    $results += "2. User must be member of Domain Admins"
                    $results += "3. Command: adprep /domainprep"
                    $results += "4. Run in each domain that will have Server $targetVersion DCs"
                    $recommendations += "Run Domain Prep on Infrastructure Master in each domain"
                }

                if (!$forestPrepRequired -and !$domainPrepRequired) {
                    $results += "No ADPREP operations required"
                }
                $results += ""

                # Backup Recommendations
                $results += "=== BACKUP REQUIREMENTS ==="
                $results += "CRITICAL: Perform these backups before upgrade:"
                $results += "1. System State Backup (includes AD database)"
                $results += "   Command: wbadmin start systemstatebackup -backuptarget:X:"
                $results += "2. Full Server Backup (recommended)"
                $results += "3. Export DHCP configuration (if DHCP role installed)"
                $results += "4. Document DNS zones and settings"
                $results += "5. Export Group Policy Objects"
                $results += "   Command: Backup-GPO -All -Path C:\\GPOBackup"
                $recommendations += "Test backup restoration procedures before upgrade"
                $recommendations += "Verify backup completeness and accessibility"
                $results += ""

                # Upgrade Order Recommendations
                $results += "=== UPGRADE ORDER STRATEGY ==="
                if ($fsmoRoles.Count -gt 0) {
                    $results += "FSMO ROLE HOLDER DETECTED"
                    $results += "Recommended upgrade order:"
                    $results += "1. Upgrade non-FSMO DCs first"
                    $results += "2. Transfer FSMO roles to upgraded DCs"
                    $results += "3. Upgrade this DC last"
                    $recommendations += "Consider temporarily transferring FSMO roles"
                } else {
                    $results += "Safe to upgrade early (no FSMO roles)"
                    $results += "Recommended: Upgrade after ADPREP but before FSMO holders"
                }
                $results += ""

                # Post-Upgrade Verification
                $results += "=== POST-UPGRADE VERIFICATION CHECKLIST ==="
                $results += "After upgrade, verify:"
                $results += "- Active Directory service starts successfully"
                $results += "- Domain controller advertises all services"
                $results += "   Command: dcdiag /test:advertising"
                $results += "- Replication is working"
                $results += "   Command: repadmin /replsummary"
                $results += "- SYSVOL share is accessible"
                $results += "- DNS service (if installed) is working"
                $results += "- Global Catalog promotion (if applicable)"
                $results += "- Client authentication and logon"
                $results += "- Group Policy application"
                $results += "- Time synchronization with PDC"
                $results += ""

                # Calculate readiness score
                $readinessScore = 100
                if ($errors.Count -gt 0) { $readinessScore -= ($errors.Count * 30) }
                if ($warnings.Count -gt 0) { $readinessScore -= ($warnings.Count * 15) }
                if ($forestPrepRequired) { $readinessScore -= 20 }
                if ($domainPrepRequired) { $readinessScore -= 15 }
                if ($fsmoRoles.Count -gt 0) { $readinessScore -= 10 }

                $readinessLevel = if ($readinessScore -ge 85) { "EXCELLENT" }
                                 elseif ($readinessScore -ge 70) { "GOOD" }
                                 elseif ($readinessScore -ge 50) { "FAIR" }
                                 else { "POOR" }

                # Summary
                $results += "=== DOMAIN CONTROLLER UPGRADE READINESS ==="
                $results += "Readiness Score: $readinessScore/100 ($readinessLevel)"
                $results += "Target Version: Windows Server $targetVersion"
                $results += "FSMO Roles: $($fsmoRoles.Count)"
                $results += "Forest Prep Required: $(if ($forestPrepRequired) { 'YES' } else { 'NO' })"
                $results += "Domain Prep Required: $(if ($domainPrepRequired) { 'YES' } else { 'NO' })"
                $results += "Errors: $($errors.Count)"
                $results += "Warnings: $($warnings.Count)"
                $results += ""

                if ($errors.Count -gt 0) {
                    $results += "=== CRITICAL ISSUES ==="
                    foreach ($error in $errors) {
                        $results += "$error"
                    }
                    $results += ""
                }

                if ($warnings.Count -gt 0) {
                    $results += "=== WARNINGS ==="
                    foreach ($warning in $warnings) {
                        $results += "$warning"
                    }
                    $results += ""
                }

                if ($recommendations.Count -gt 0) {
                    $results += "=== RECOMMENDATIONS ==="
                    foreach ($recommendation in $recommendations) {
                        $results += "- $recommendation"
                    }
                    $results += ""
                }

                # Final recommendation
                $results += "=== FINAL RECOMMENDATION ==="
                if ($errors.Count -eq 0 -and !$forestPrepRequired -and !$domainPrepRequired) {
                    $results += "PROCEED: DC is ready for in-place upgrade"
                    $results += "- Complete System State backup before proceeding"
                    $results += "- Monitor replication during and after upgrade"
                } elseif ($errors.Count -eq 0) {
                    $results += "PROCEED AFTER PREPARATION: Address requirements first"
                    $results += "- Complete Forest/Domain Prep if required"
                    $results += "- Address all warnings where possible"
                    $results += "- Follow recommended upgrade order"
                } else {
                    $results += "DO NOT PROCEED: Critical issues must be resolved"
                    $results += "- Fix all replication errors"
                    $results += "- Resolve storage and configuration issues"
                    $results += "- Re-run preparation after fixes"
                }

                $results += ""
                $results += "DC upgrade preparation completed: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"

            } catch {
                $errors += "Critical error during DC preparation: $($_.Exception.Message)"
                $results += "ERROR: $($_.Exception.Message)"
            }

            return @{
                Results = $results
                TargetVersion = $targetVersion
                Errors = $errors.Count
                Warnings = $warnings.Count
                FSMORoles = $fsmoRoles.Count
                ForestPrepRequired = $forestPrepRequired
                DomainPrepRequired = $domainPrepRequired
                ReadinessScore = if ($readinessScore) { $readinessScore } else { 0 }
                ReadinessLevel = if ($readinessLevel) { $readinessLevel } else { "UNKNOWN" }
            }
        }

        # Start async operation
        Start-AsyncOperation -ScriptBlock {
            & $dcUpgradeScript $TargetWindowsVersion $PerformForestPrep.IsPresent $PerformDomainPrep.IsPresent
        } -CompletedCallback {
            param($data)

            try {
                $reportContent = $data.Results -join "`r`n"

                # Save detailed report
                $reportPath = "$env:USERPROFILE\Desktop\WDCA_DC_Upgrade_Prep_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt"
                Set-Content -Path $reportPath -Value $reportContent -Encoding UTF8

                # Determine message type
                $messageType = if ($data.Errors -gt 0) {
                    [System.Windows.MessageBoxImage]::Error
                } elseif ($data.ForestPrepRequired -or $data.DomainPrepRequired -or $data.Warnings -gt 2) {
                    [System.Windows.MessageBoxImage]::Warning
                } else {
                    [System.Windows.MessageBoxImage]::Information
                }

                $title = "WDCA - DC Upgrade Preparation ($($data.ReadinessLevel))"

                # Create summary message
                $summaryMessage = "Domain Controller Upgrade Preparation Complete`n`n"
                $summaryMessage += "Target: Windows Server $($data.TargetVersion)`n"
                $summaryMessage += "Readiness: $($data.ReadinessScore)/100 ($($data.ReadinessLevel))`n"
                $summaryMessage += "FSMO Roles: $($data.FSMORoles)`n"
                $summaryMessage += "Forest Prep: $(if ($data.ForestPrepRequired) { 'REQUIRED' } else { 'Not needed' })`n"
                $summaryMessage += "Domain Prep: $(if ($data.DomainPrepRequired) { 'REQUIRED' } else { 'Not needed' })`n"
                $summaryMessage += "Errors: $($data.Errors) | Warnings: $($data.Warnings)`n`n"

                if ($data.Errors -eq 0 -and !$data.ForestPrepRequired -and !$data.DomainPrepRequired) {
                    $summaryMessage += "DC ready for upgrade after backup"
                } elseif ($data.Errors -eq 0) {
                    $summaryMessage += "Complete ADPREP operations first"
                } else {
                    $summaryMessage += "Critical issues must be resolved"
                }

                $summaryMessage += "`n`nDetailed report: $reportPath"

                [System.Windows.MessageBox]::Show($summaryMessage, $title, [System.Windows.MessageBoxButton]::OK, $messageType)

                Write-Logger "DC upgrade preparation completed for Windows Server $($data.TargetVersion)" "SUCCESS"

            } catch {
                Write-Logger "Error in DC upgrade preparation callback: $($_.Exception.Message)" "ERROR"
                [System.Windows.MessageBox]::Show(
                    "DC preparation completed but error processing results: $($_.Exception.Message)",
                    "WDCA - Processing Error",
                    [System.Windows.MessageBoxButton]::OK,
                    [System.Windows.MessageBoxImage]::Warning
                )
            }
        } -OperationName "DC Upgrade Preparation (Server $TargetWindowsVersion)"

    } catch {
        Write-Logger "Error in DC Upgrade Preparation: $($_.Exception.Message)" "ERROR"
        [System.Windows.MessageBox]::Show(
            "Failed to start DC upgrade preparation: $($_.Exception.Message)",
            "WDCA - DC Preparation Error",
            [System.Windows.MessageBoxButton]::OK,
            [System.Windows.MessageBoxImage]::Error
        )
    }
}

function Invoke-FSMORoleAnalysis {
    <#
    .SYNOPSIS
        Analyzes FSMO roles in the Active Directory environment
    #>

    Write-Logger "Starting FSMO Role Analysis" "INFO"

    try {
        $analysisScript = {
            $results = @()

            try {
                Import-Module ActiveDirectory -ErrorAction Stop

                $results += "=== FSMO ROLES ANALYSIS ==="
                $results += "Analysis Time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
                $results += ""

                # Get Forest and Domain info
                $forest = Get-ADForest
                $domain = Get-ADDomain
                $currentDC = "$($env:COMPUTERNAME).$($domain.DNSRoot)"

                # Forest-wide FSMO Roles
                $results += "=== FOREST-WIDE FSMO ROLES ==="
                $results += "Schema Master: $($forest.SchemaMaster)"
                $results += "Domain Naming Master: $($forest.DomainNamingMaster)"
                $results += ""

                # Domain FSMO Roles
                $results += "=== DOMAIN FSMO ROLES ==="
                $results += "PDC Emulator: $($domain.PDCEmulator)"
                $results += "RID Master: $($domain.RIDMaster)"
                $results += "Infrastructure Master: $($domain.InfrastructureMaster)"
                $results += ""

                # Check if current DC holds any FSMO roles
                $currentDCRoles = @()
                if ($forest.SchemaMaster -eq $currentDC) { $currentDCRoles += "Schema Master" }
                if ($forest.DomainNamingMaster -eq $currentDC) { $currentDCRoles += "Domain Naming Master" }
                if ($domain.PDCEmulator -eq $currentDC) { $currentDCRoles += "PDC Emulator" }
                if ($domain.RIDMaster -eq $currentDC) { $currentDCRoles += "RID Master" }
                if ($domain.InfrastructureMaster -eq $currentDC) { $currentDCRoles += "Infrastructure Master" }

                $results += "=== CURRENT DC ROLE ANALYSIS ==="
                $results += "Current DC: $currentDC"
                if ($currentDCRoles.Count -gt 0) {
                    $results += "FSMO Roles on this DC: $($currentDCRoles.Count)"
                    foreach ($role in $currentDCRoles) {
                        $results += "  - $role"
                    }
                    $results += ""
                    $results += "UPGRADE IMPACT:"
                    $results += "- This DC holds critical FSMO roles"
                    $results += "- Consider transferring roles before upgrade"
                    $results += "- Extended downtime will affect these services"
                } else {
                    $results += "FSMO Roles on this DC: None"
                    $results += "Safe for upgrade (no FSMO roles)"
                }
                $results += ""

                # Get all DCs in domain
                $results += "=== ALL DOMAIN CONTROLLERS ==="
                $allDCs = Get-ADDomainController -Filter *
                foreach ($dc in $allDCs) {
                    $results += "DC: $($dc.Name) ($($dc.IPv4Address))"
                    $results += "  Site: $($dc.Site)"
                    $results += "  OS: $($dc.OperatingSystem)"
                    $results += "  GC: $(if ($dc.IsGlobalCatalog) { 'Yes' } else { 'No' })"
                    $results += ""
                }

                # FSMO Transfer Commands
                $results += "=== FSMO TRANSFER COMMANDS ==="
                $results += "To transfer roles FROM this DC to another DC:"
                $results += ""
                $results += "# Connect to target DC first:"
                $results += "netdom query fsmo"
                $results += ""
                $results += "# Transfer individual roles:"
                if ($currentDCRoles -contains "Schema Master") {
                    $results += "Move-ADDirectoryServerOperationMasterRole -Identity <TargetDC> -OperationMasterRole SchemaMaster"
                }
                if ($currentDCRoles -contains "Domain Naming Master") {
                    $results += "Move-ADDirectoryServerOperationMasterRole -Identity <TargetDC> -OperationMasterRole DomainNamingMaster"
                }
                if ($currentDCRoles -contains "PDC Emulator") {
                    $results += "Move-ADDirectoryServerOperationMasterRole -Identity <TargetDC> -OperationMasterRole PDCEmulator"
                }
                if ($currentDCRoles -contains "RID Master") {
                    $results += "Move-ADDirectoryServerOperationMasterRole -Identity <TargetDC> -OperationMasterRole RIDMaster"
                }
                if ($currentDCRoles -contains "Infrastructure Master") {
                    $results += "Move-ADDirectoryServerOperationMasterRole -Identity <TargetDC> -OperationMasterRole InfrastructureMaster"
                }

                if ($currentDCRoles.Count -gt 0) {
                    $results += ""
                    $results += "# Transfer all roles at once:"
                    $results += "Move-ADDirectoryServerOperationMasterRole -Identity <TargetDC> -OperationMasterRole SchemaMaster,DomainNamingMaster,PDCEmulator,RIDMaster,InfrastructureMaster"
                }

            } catch {
                $results += "ERROR: $($_.Exception.Message)"
            }

            return $results
        }

        Start-AsyncOperation -ScriptBlock $analysisScript -CompletedCallback {
            param($data)

            $reportContent = $data -join "`r`n"
            $reportPath = "$env:USERPROFILE\Desktop\WDCA_FSMO_Analysis_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt"
            Set-Content -Path $reportPath -Value $reportContent -Encoding UTF8

            [System.Windows.MessageBox]::Show(
                "FSMO Role Analysis completed.`n`nReport saved to:`n$reportPath",
                "WDCA - FSMO Analysis Complete",
                [System.Windows.MessageBoxButton]::OK,
                [System.Windows.MessageBoxImage]::Information
            )
        } -OperationName "FSMO Role Analysis"

    } catch {
        Write-Logger "Error in FSMO Analysis: $($_.Exception.Message)" "ERROR"
        [System.Windows.MessageBox]::Show(
            "Failed to start FSMO analysis: $($_.Exception.Message)",
            "WDCA - FSMO Analysis Error",
            [System.Windows.MessageBoxButton]::OK,
            [System.Windows.MessageBoxImage]::Error
        )
    }
}

function Invoke-ADReplicationCheck {
    <#
    .SYNOPSIS
        Performs comprehensive AD replication health check
    #>

    Write-Logger "Starting AD Replication Check" "INFO"

    try {
        $replicationScript = {
            $results = @()

            try {
                Import-Module ActiveDirectory -ErrorAction Stop

                $results += "=== AD REPLICATION HEALTH CHECK ==="
                $results += "Check Time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
                $results += "Current DC: $env:COMPUTERNAME"
                $results += ""

                # Replication Partners
                $results += "=== REPLICATION PARTNERS ==="
                $partners = Get-ADReplicationPartnerMetadata -Target $env:COMPUTERNAME -ErrorAction Stop
                $results += "Total Partners: $($partners.Count)"
                $results += ""

                $healthyPartners = 0
                $errorPartners = 0

                foreach ($partner in $partners) {
                    $results += "Partner: $($partner.Partner)"
                    $results += "  Partition: $($partner.Partition)"
                    $results += "  Last Replication: $($partner.LastReplicationAttempt)"
                    $results += "  Last Success: $($partner.LastReplicationSuccess)"
                    $results += "  Result: $($partner.LastReplicationResult)"

                    if ($partner.LastReplicationResult -eq 0) {
                        $results += "  Status: HEALTHY"
                        $healthyPartners++
                    } else {
                        $results += "  Status: ERROR"
                        $errorPartners++
                    }
                    $results += ""
                }

                $results += "=== REPLICATION SUMMARY ==="
                $results += "Healthy Partners: $healthyPartners"
                $results += "Partners with Errors: $errorPartners"
                $results += ""

                # Replication Failures
                $results += "=== REPLICATION FAILURES ==="
                try {
                    $failures = Get-ADReplicationFailure -Target $env:COMPUTERNAME -ErrorAction SilentlyContinue
                    if ($failures) {
                        $results += "Active Failures: $($failures.Count)"
                        foreach ($failure in $failures) {
                            $results += "Failure: $($failure.Server) - $($failure.LastError)"
                        }
                    } else {
                        $results += "No active replication failures"
                    }
                } catch {
                    $results += "Could not check replication failures: $($_.Exception.Message)"
                }
                $results += ""

                # Replication Queue
                $results += "=== REPLICATION QUEUE ==="
                try {
                    $queue = Get-ADReplicationQueueOperation -Server $env:COMPUTERNAME -ErrorAction SilentlyContinue
                    if ($queue) {
                        $results += "Queued Operations: $($queue.Count)"
                        foreach ($op in $queue | Select-Object -First 5) {
                            $results += "Operation: $($op.PartitionName) - $($op.OperationType)"
                        }
                        if ($queue.Count -gt 5) {
                            $results += "... and $($queue.Count - 5) more operations"
                        }
                    } else {
                        $results += "No operations in replication queue"
                    }
                } catch {
                    $results += "Could not check replication queue: $($_.Exception.Message)"
                }
                $results += ""

                # DCDiag equivalent checks
                $results += "=== DCDIAG-STYLE CHECKS ==="
                $results += "Testing critical replication functions..."
                $results += ""

                # Connectivity test
                $results += "Connectivity Test:"
                try {
                    $domain = Get-ADDomain
                    $otherDCs = Get-ADDomainController -Filter "Name -ne '$env:COMPUTERNAME'"

                    foreach ($dc in $otherDCs | Select-Object -First 3) {
                        if (Test-Connection -ComputerName $dc.IPv4Address -Count 1 -Quiet) {
                            $results += "  $($dc.Name) - Reachable"
                        } else {
                            $results += "  $($dc.Name) - Not reachable"
                        }
                    }
                } catch {
                    $results += "  Could not test connectivity: $($_.Exception.Message)"
                }
                $results += ""

                # Recommendations
                $results += "=== RECOMMENDATIONS ==="
                if ($errorPartners -gt 0) {
                    $results += "CRITICAL: Fix replication errors before DC upgrade"
                    $results += "- Run: repadmin /showrepl for detailed error information"
                    $results += "- Run: repadmin /replicate to force replication"
                    $results += "- Check network connectivity between DCs"
                } else {
                    $results += "Replication appears healthy"
                    $results += "- Safe to proceed with DC upgrade planning"
                }

                $results += ""
                $results += "Manual commands for further analysis:"
                $results += "- repadmin /replsummary - Overall replication status"
                $results += "- repadmin /showrepl - Detailed replication info"
                $results += "- dcdiag /test:replications - Full replication test"
                $results += "- Get-ADReplicationUpToDatenessVectorTable - Vector table"

            } catch {
                $results += "ERROR: $($_.Exception.Message)"
            }

            return $results
        }

        Start-AsyncOperation -ScriptBlock $replicationScript -CompletedCallback {
            param($data)

            $reportContent = $data -join "`r`n"
            $reportPath = "$env:USERPROFILE\Desktop\WDCA_Replication_Check_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt"
            Set-Content -Path $reportPath -Value $reportContent -Encoding UTF8

            [System.Windows.MessageBox]::Show(
                "AD Replication Check completed.`n`nReport saved to:`n$reportPath",
                "WDCA - Replication Check Complete",
                [System.Windows.MessageBoxButton]::OK,
                [System.Windows.MessageBoxImage]::Information
            )
        } -OperationName "AD Replication Check"

    } catch {
        Write-Logger "Error in Replication Check: $($_.Exception.Message)" "ERROR"
        [System.Windows.MessageBox]::Show(
            "Failed to start replication check: $($_.Exception.Message)",
            "WDCA - Replication Check Error",
            [System.Windows.MessageBoxButton]::OK,
            [System.Windows.MessageBoxImage]::Error
        )
    }
}


function Invoke-NetworkConfiguration {
    <#
    .SYNOPSIS
        Configures network settings
    .DESCRIPTION
        Sets IP address, subnet mask, gateway, DNS servers, IPv6 settings, or enables DHCP
    #>
    Write-Logger "Configuring network settings" "INFO"

    # Get values from UI
    $useDHCP = if ($sync.WPFDHCP) { $sync.WPFDHCP.IsChecked } else { $false }
    $useStaticIP = if ($sync.WPFStaticIP) { $sync.WPFStaticIP.IsChecked } else { $true }
    $ipAddress = if ($sync.WPFNetworkIP) { $sync.WPFNetworkIP.Text.Trim() } else { "" }
    $subnetMask = if ($sync.WPFNetworkSubnet) { $sync.WPFNetworkSubnet.Text.Trim() } else { "" }
    $gateway = if ($sync.WPFNetworkGateway) { $sync.WPFNetworkGateway.Text.Trim() } else { "" }
    $dnsServer = if ($sync.WPFNetworkDNS) { $sync.WPFNetworkDNS.Text.Trim() } else { "" }
    $dnsAltServer = if ($sync.WPFNetworkDNSAlt) { $sync.WPFNetworkDNSAlt.Text.Trim() } else { "" }
    $disableIPv6 = if ($sync.WPFDisableIPv6) { $sync.WPFDisableIPv6.IsChecked } else { $false }

    # Validate input for Static IP
    if ($useStaticIP -and [string]::IsNullOrEmpty($ipAddress)) {
        Write-Logger "IP Address is required for static IP configuration" "ERROR"
        [System.Windows.MessageBox]::Show("Please enter an IP address for static configuration.", "WDCA - Network Configuration", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Warning)
        return
    }

    # Validate IP address format for Static IP
    if ($useStaticIP) {
        try {
            [System.Net.IPAddress]::Parse($ipAddress) | Out-Null
        }
        catch {
            Write-Logger "Invalid IP address format: $ipAddress" "ERROR"
            [System.Windows.MessageBox]::Show("Please enter a valid IP address.", "WDCA - Network Configuration", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Warning)
            return
        }
    }

    try {
        # Get the primary network adapter
        $adapter = Get-NetAdapter | Where-Object { $_.Status -eq "Up" -and $_.InterfaceType -eq 6 } | Select-Object -First 1
        if (-not $adapter) {
            Write-Logger "No active network adapter found" "ERROR"
            [System.Windows.MessageBox]::Show("No active network adapter found.", "WDCA - Network Configuration", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Error)
            return
        }

        Write-Logger "Configuring adapter: $($adapter.Name)" "INFO"

        if ($useDHCP) {
            # Configure DHCP
            Write-Logger "Enabling DHCP configuration" "INFO"

            # Remove existing static IP configuration
            Remove-NetIPAddress -InterfaceAlias $adapter.Name -Confirm:$false -ErrorAction SilentlyContinue
            Remove-NetRoute -InterfaceAlias $adapter.Name -Confirm:$false -ErrorAction SilentlyContinue

            # Enable DHCP for IP address
            Set-NetIPInterface -InterfaceAlias $adapter.Name -Dhcp Enabled -ErrorAction Stop
            Write-Logger "DHCP enabled for IP address" "INFO"

            # Set DNS to automatic (DHCP) - always use automatic DNS with DHCP
            Set-DnsClientServerAddress -InterfaceAlias $adapter.Name -ResetServerAddresses -ErrorAction Stop
            Write-Logger "DNS set to automatic (DHCP)" "INFO"

            # Renew DHCP lease to get new configuration
            $null = Invoke-Command -ScriptBlock { ipconfig /renew } -ErrorAction SilentlyContinue
            Write-Logger "DHCP lease renewed" "INFO"
        }
        else {
            # Configure Static IP
            Write-Logger "Configuring static IP" "INFO"

            # Remove existing IP configuration
            Remove-NetIPAddress -InterfaceAlias $adapter.Name -Confirm:$false -ErrorAction SilentlyContinue
            Remove-NetRoute -InterfaceAlias $adapter.Name -Confirm:$false -ErrorAction SilentlyContinue

            # Disable DHCP
            Set-NetIPInterface -InterfaceAlias $adapter.Name -Dhcp Disabled -ErrorAction Stop

            # Convert subnet mask to prefix length if provided
            $prefixLength = 24  # Default /24
            if (-not [string]::IsNullOrEmpty($subnetMask)) {
                $prefixLength = Convert-SubnetMaskToPrefixLength $subnetMask
            }

            # Set IP address
            New-NetIPAddress -InterfaceAlias $adapter.Name -IPAddress $ipAddress -PrefixLength $prefixLength -ErrorAction Stop
            Write-Logger "Set static IP address: $ipAddress/$prefixLength" "INFO"

            # Set gateway if provided
            if (-not [string]::IsNullOrEmpty($gateway)) {
                New-NetRoute -InterfaceAlias $adapter.Name -DestinationPrefix "0.0.0.0/0" -NextHop $gateway -ErrorAction Stop
                Write-Logger "Set gateway: $gateway" "INFO"
            }

            # Set DNS servers if provided
            $dnsServers = @()
            if (-not [string]::IsNullOrEmpty($dnsServer)) {
                $dnsServers += $dnsServer
            }
            if (-not [string]::IsNullOrEmpty($dnsAltServer)) {
                $dnsServers += $dnsAltServer
            }

            if ($dnsServers.Count -gt 0) {
                Set-DnsClientServerAddress -InterfaceAlias $adapter.Name -ServerAddresses $dnsServers -ErrorAction Stop
                Write-Logger "Set DNS servers: $($dnsServers -join ', ')" "INFO"
            }
        }

        # Handle IPv6 settings (applies to both DHCP and Static)
        if ($disableIPv6) {
            # Disable IPv6 on the adapter
            Disable-NetAdapterBinding -Name $adapter.Name -ComponentID ms_tcpip6 -ErrorAction SilentlyContinue
            Write-Logger "IPv6 disabled on adapter: $($adapter.Name)" "INFO"

            # Also disable IPv6 globally via registry (requires reboot to take full effect)
            try {
                Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip6\Parameters" -Name "DisabledComponents" -Value 0xff -Type DWord -ErrorAction Stop
                Write-Logger "IPv6 disabled globally (registry)" "INFO"
            }
            catch {
                Write-Logger "Warning: Could not disable IPv6 globally via registry: $($_.Exception.Message)" "WARNING"
            }
        }
        else {
            # Enable IPv6 on the adapter if it was disabled
            Enable-NetAdapterBinding -Name $adapter.Name -ComponentID ms_tcpip6 -ErrorAction SilentlyContinue
            Write-Logger "IPv6 enabled on adapter: $($adapter.Name)" "INFO"

            # Enable IPv6 globally via registry
            try {
                Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip6\Parameters" -Name "DisabledComponents" -Value 0x00 -Type DWord -ErrorAction Stop
                Write-Logger "IPv6 enabled globally (registry)" "INFO"
            }
            catch {
                Write-Logger "Warning: Could not enable IPv6 globally via registry: $($_.Exception.Message)" "WARNING"
            }
        }

        Write-Logger "Network configuration completed successfully" "INFO"

        # Show completion message
        $configType = if ($useDHCP) { "DHCP" } else { "Static IP" }
        $ipv6Status = if ($disableIPv6) { "IPv6 wurde deaktiviert." } else { "IPv6 ist aktiviert." }
        $message = "Network configuration completed successfully.`n`nConfiguration: $configType`n$ipv6Status"

        if ($disableIPv6) {
            $message += "`n`nHinweis: Ein Neustart wird empfohlen fÃ¼r vollstÃ¤ndige IPv6-Deaktivierung."
        }

        if ($useDHCP) {
            $message += "`n`nDHCP lease wurde erneuert. Neue IP-Konfiguration wird automatisch bezogen."
        }

        [System.Windows.MessageBox]::Show($message, "WDCA - Network Configuration", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Information)
    }
    catch {
        Write-Logger "Error configuring network: $($_.Exception.Message)" "ERROR"
        [System.Windows.MessageBox]::Show("Error configuring network: $($_.Exception.Message)", "WDCA - Network Configuration", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Error)
    }
}

function Invoke-PreCloneCleanup {
    <#
    .SYNOPSIS
        Performs system cleanup before cloning

    .DESCRIPTION
        Cleans temporary files, logs, and other data to reduce image size
    #>

    Write-Logger "Starting pre-clone cleanup" "INFO"

    # Get cleanup options from UI
    $cleanTemp = if ($sync.WPFCleanupTemp) { $sync.WPFCleanupTemp.IsChecked } else { $true }
    $cleanLogs = if ($sync.WPFCleanupLogs) { $sync.WPFCleanupLogs.IsChecked } else { $true }
    $cleanRecycle = if ($sync.WPFCleanupRecycle) { $sync.WPFCleanupRecycle.IsChecked } else { $true }

    $confirmResult = [System.Windows.MessageBox]::Show(
        "Perform pre-clone cleanup?`n`nThis will remove temporary files, logs, and other unnecessary data.",
        "WDCA - Pre-Clone Cleanup",
        [System.Windows.MessageBoxButton]::YesNo,
        [System.Windows.MessageBoxImage]::Question
    )

    if ($confirmResult -ne [System.Windows.MessageBoxResult]::Yes) {
        Write-Logger "Pre-clone cleanup cancelled by user" "INFO"
        return
    }

    try {
        $cleanupResults = @()

        Write-Progress-Logger "Starting cleanup process..." 10

        if ($cleanTemp) {
            Write-Progress-Logger "Cleaning temporary files..." 25
            $tempCleaned = Clear-TemporaryFiles
            $cleanupResults += "Temporary files: $tempCleaned"
        }

        if ($cleanLogs) {
            Write-Progress-Logger "Cleaning event logs..." 50
            $logsCleaned = Clear-EventLogs
            $cleanupResults += "Event logs: $logsCleaned"
        }

        if ($cleanRecycle) {
            Write-Progress-Logger "Emptying recycle bin..." 75
            $recycleCleaned = Clear-RecycleBin
            $cleanupResults += "Recycle bin: $recycleCleaned"
        }

        Write-Progress-Logger "Running disk cleanup..." 90
        Invoke-DiskCleanup

        Write-Progress-Logger "Cleanup completed" 100

        $resultMessage = "Pre-clone cleanup completed successfully!`n`n" + ($cleanupResults -join "`n")
        Write-Logger "Pre-clone cleanup completed" "INFO"
        [System.Windows.MessageBox]::Show($resultMessage, "WDCA - Cleanup Complete", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Information)

    }
    catch {
        Write-Logger "Error during pre-clone cleanup: $($_.Exception.Message)" "ERROR"
        [System.Windows.MessageBox]::Show("Error during cleanup: $($_.Exception.Message)", "WDCA - Cleanup Error", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Error)
    }
    finally {
        # Reset progress bar
        if ($sync.WPFProgressBar) {
            $sync.WPFProgressBar.Dispatcher.Invoke([action]{
                $sync.WPFProgressBar.Value = 0
            })
        }
    }
}

function Invoke-RDPConfiguration {
    <#
    .SYNOPSIS
        Enables and configures Remote Desktop
    .DESCRIPTION
        Enables Remote Desktop and configures authentication settings without restart
    #>
    Write-Logger "Configuring Remote Desktop" "INFO"
    try {
        # Check current RDP status
        $currentRDPStatus = Get-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server" -Name "fDenyTSConnections" -ErrorAction SilentlyContinue
        $rdpWasDisabled = $currentRDPStatus.fDenyTSConnections -eq 1

        # Enable Remote Desktop
        Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server" -Name "fDenyTSConnections" -Value 0
        Write-Logger "Enabled Remote Desktop" "INFO"

        # Enable Remote Desktop through Windows Firewall
        try {
            Enable-NetFirewallRule -DisplayGroup "Remote Desktop" -ErrorAction Stop
            Write-Logger "Enabled Remote Desktop firewall rules" "INFO"
        }
        catch {
            # Fallback for older systems or different language versions
            netsh advfirewall firewall set rule group="Remote Desktop" new enable=yes
            Write-Logger "Enabled Remote Desktop firewall rules (netsh)" "INFO"
        }

        # Check if Network Level Authentication should be required
        $requireNLA = if ($sync.WPFRDPNetworkAuth) { $sync.WPFRDPNetworkAuth.IsChecked } else { $true }

        if ($requireNLA) {
            Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name "UserAuthentication" -Value 1
            Write-Logger "Enabled Network Level Authentication for RDP" "INFO"
        }
        else {
            Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name "UserAuthentication" -Value 0
            Write-Logger "Disabled Network Level Authentication for RDP" "INFO"
        }

        # Force refresh of Terminal Services configuration (no restart needed)
        try {
            # Restart Terminal Services to apply changes immediately
            $terminalService = Get-Service -Name "TermService" -ErrorAction SilentlyContinue
            if ($terminalService -and $terminalService.Status -eq "Running") {
                Write-Logger "Refreshing Terminal Services configuration" "INFO"
                Restart-Service -Name "TermService" -Force -ErrorAction Stop
                Write-Logger "Terminal Services restarted successfully" "INFO"
            }
            else {
                # Start the service if it's not running
                Start-Service -Name "TermService" -ErrorAction Stop
                Write-Logger "Terminal Services started" "INFO"
            }
        }
        catch {
            Write-Logger "Warning: Could not restart Terminal Services: $($_.Exception.Message)" "WARNING"
            Write-Logger "RDP settings applied, but may require manual service restart" "WARNING"
        }

        # Get current RDP port for information
        try {
            $rdpPort = Get-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name "PortNumber" -ErrorAction SilentlyContinue
            if ($rdpPort) {
                Write-Logger "RDP is configured on port: $($rdpPort.PortNumber)" "INFO"
            }
        }
        catch {
            Write-Logger "Could not determine RDP port" "WARNING"
        }

        Write-Logger "Remote Desktop configuration completed successfully" "INFO"

        # Prepare status message
        $statusMessage = "Remote Desktop has been enabled and configured successfully.`n`n"
        $statusMessage += "Configuration applied:`n"
        $statusMessage += "- Remote Desktop: Enabled`n"
        $statusMessage += "- Firewall Rules: Enabled`n"
        $statusMessage += "- Network Level Auth: $(if ($requireNLA) { 'Enabled' } else { 'Disabled' })`n"
        $statusMessage += "- Terminal Services: Refreshed`n`n"
        $statusMessage += "RDP is ready to use immediately - no restart required."

        [System.Windows.MessageBox]::Show($statusMessage, "WDCA - RDP Configuration", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Information)
    }
    catch {
        Write-Logger "Error configuring Remote Desktop: $($_.Exception.Message)" "ERROR"
        [System.Windows.MessageBox]::Show("Error configuring Remote Desktop: $($_.Exception.Message)", "WDCA - RDP Configuration", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Error)
    }
}

function Invoke-SFCScan {
    <#
    .SYNOPSIS
        Runs System File Checker (SFC) in a new terminal with real-time output
    .DESCRIPTION
        Creates a simple PowerShell script that runs SFC scan in a new terminal window
        and displays real-time progress and results.
    #>

    Write-Logger "Starting SFC scan in new terminal" "INFO"

    $tempScriptPath = Join-Path $env:TEMP "WDCA_SFC_Scan.ps1"
    $logPath = Join-Path $env:TEMP "wdca_sfc.log"

    $scriptContent = @"
# Terminal styling
`$Host.UI.RawUI.BackgroundColor = "Black"
`$Host.UI.RawUI.ForegroundColor = "White"
Clear-Host

# Simple logging function
function Write-SFCLog {
    param([string]`$Message, [string]`$Level = "INFO")
    try {
        `$timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        Add-Content -Path "$logPath" -Value "[`$timestamp] [`$Level] `$Message" -Encoding UTF8 -ErrorAction SilentlyContinue
    } catch { }
}

# Header
Write-Host ("=" * 50) -ForegroundColor Cyan
Write-Host "  WDCA System File Checker (SFC)" -ForegroundColor Cyan
Write-Host ("=" * 50) -ForegroundColor Cyan
Write-Host ""

Write-SFCLog "SFC scan started" "INFO"
Write-Host "[INFO] Starting System File Checker scan..." -ForegroundColor Cyan
Write-Host "[INFO] This may take several minutes - please wait" -ForegroundColor Cyan
Write-Host ""

try {
    `$stopwatch = [System.Diagnostics.Stopwatch]::StartNew()

    # Run SFC with real-time output
    Write-Host "SFC Output:" -ForegroundColor Yellow
    Write-Host ("-" * 30) -ForegroundColor DarkGray

    `$sfcProcess = Start-Process -FilePath "sfc.exe" -ArgumentList "/scannow" -Wait -PassThru -NoNewWindow

    `$stopwatch.Stop()
    `$duration = `$stopwatch.Elapsed.ToString("mm\:ss")

    Write-Host ""
    Write-Host ("-" * 30) -ForegroundColor DarkGray

    # Show results based on exit code
    switch (`$sfcProcess.ExitCode) {
        0 {
            Write-Host "[SUCCESS] SFC completed - No issues found (Duration: `$duration)" -ForegroundColor Green
            Write-SFCLog "SFC completed successfully in `$duration" "SUCCESS"
        }
        1 {
            Write-Host "[SUCCESS] SFC completed - Found and repaired files (Duration: `$duration)" -ForegroundColor Green
            Write-SFCLog "SFC found and repaired issues in `$duration" "SUCCESS"
        }
        2 {
            Write-Host "[WARNING] SFC completed - Restart required (Duration: `$duration)" -ForegroundColor Yellow
            Write-SFCLog "SFC completed, restart required (Duration: `$duration)" "WARNING"
        }
        3 {
            Write-Host "[WARNING] SFC completed - Some files could not be repaired (Duration: `$duration)" -ForegroundColor Yellow
            Write-SFCLog "SFC found unrepaired issues (Duration: `$duration)" "WARNING"
        }
        default {
            Write-Host "[WARNING] SFC completed with exit code `$(`$sfcProcess.ExitCode) (Duration: `$duration)" -ForegroundColor Yellow
            Write-SFCLog "SFC completed with exit code `$(`$sfcProcess.ExitCode) (Duration: `$duration)" "WARNING"
        }
    }

    # Show recent CBS.log entries if available
    `$cbsLogPath = Join-Path `$env:SystemRoot "Logs\CBS\CBS.log"
    if (Test-Path `$cbsLogPath) {
        Write-Host ""
        Write-Host "Recent CBS.log entries:" -ForegroundColor DarkCyan
        try {
            Get-Content `$cbsLogPath -Tail 10 -ErrorAction Stop | ForEach-Object {
                if (`$_ -match "error|failed|corrupt") {
                    Write-Host "  `$_" -ForegroundColor Red
                } elseif (`$_ -match "repaired|success") {
                    Write-Host "  `$_" -ForegroundColor Green
                } else {
                    Write-Host "  `$_" -ForegroundColor Gray
                }
            }
        }
        catch {
            Write-Host "  Could not read CBS.log" -ForegroundColor Yellow
        }
    }

    # Simple status summary
    Write-Host ""
    if (`$sfcProcess.ExitCode -eq 0) {
        Write-Host "Status: System files are healthy" -ForegroundColor Green
    } elseif (`$sfcProcess.ExitCode -eq 1) {
        Write-Host "Status: Issues found and repaired" -ForegroundColor Green
    } elseif (`$sfcProcess.ExitCode -eq 2) {
        Write-Host "Status: Restart required to complete repairs" -ForegroundColor Yellow
    } elseif (`$sfcProcess.ExitCode -eq 3) {
        Write-Host "Status: Some issues require manual attention" -ForegroundColor Yellow
        Write-Host "Tip: Try running DISM /Online /Cleanup-Image /RestoreHealth" -ForegroundColor Cyan
    }

}
catch {
    Write-Host "[ERROR] Failed to run SFC: `$(`$_.Exception.Message)" -ForegroundColor Red
    Write-SFCLog "SFC error: `$(`$_.Exception.Message)" "ERROR"
}

# Footer
Write-Host ""
Write-Host ("-" * 50) -ForegroundColor DarkGray
Write-Host "Log saved to: $logPath" -ForegroundColor Cyan
Write-SFCLog "SFC scan completed" "INFO"

Write-Host ""
Write-Host "Press any key to close..." -ForegroundColor Blue
`$null = `$Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
"@

    # Create and run script
    try {
        Set-Content -Path $tempScriptPath -Value $scriptContent -Encoding UTF8
        Write-Logger "Created SFC script: $tempScriptPath" "INFO"

        $sfcProcess = Start-Process -FilePath "powershell.exe" -ArgumentList @(
            "-NoProfile"
            "-ExecutionPolicy", "Bypass"
            "-File", "`"$tempScriptPath`""
        ) -WindowStyle Normal -PassThru

        Write-Logger "Started SFC terminal (PID: $($sfcProcess.Id))" "SUCCESS"

        # Cleanup script after use
        Start-Job -ScriptBlock {
            param($ProcessId, $ScriptPath)
            try {
                $process = Get-Process -Id $ProcessId -ErrorAction SilentlyContinue
                if ($process) { $process.WaitForExit() }
                Start-Sleep -Seconds 5
                if (Test-Path $ScriptPath) {
                    Remove-Item $ScriptPath -Force -ErrorAction SilentlyContinue
                }
            } catch { }
        } -ArgumentList $sfcProcess.Id, $tempScriptPath | Out-Null

    }
    catch {
        Write-Logger "Failed to start SFC: $($_.Exception.Message)" "ERROR"
        [System.Windows.MessageBox]::Show(
            "Failed to start SFC scan.`n$($_.Exception.Message)",
            "WDCA - SFC Error",
            [System.Windows.MessageBoxButton]::OK,
            [System.Windows.MessageBoxImage]::Error
        )

        if (Test-Path $tempScriptPath) {
            Remove-Item $tempScriptPath -Force -ErrorAction SilentlyContinue
        }
    }
}

function Invoke-SysprepPreparation {
    <#
    .SYNOPSIS
        Prepares the system for Sysprep by running cleanup and checks

    .DESCRIPTION
        Performs pre-Sysprep tasks like cleanup and validation
    #>

    Write-Logger "Preparing system for Sysprep" "INFO"

    try {
        Write-Progress-Logger "Checking Sysprep prerequisites..." 20

        # Check if system is domain-joined (may need special handling)
        $computerSystem = Get-WmiObject -Class Win32_ComputerSystem
        if ($computerSystem.PartOfDomain) {
            Write-Logger "System is domain-joined. Consider running Sysprep in audit mode first." "WARNING"
            $domainWarning = [System.Windows.MessageBox]::Show(
                "This system is joined to a domain. This may affect Sysprep operation.`n`nContinue with preparation?",
                "WDCA - Domain Warning",
                [System.Windows.MessageBoxButton]::YesNo,
                [System.Windows.MessageBoxImage]::Warning
            )

            if ($domainWarning -ne [System.Windows.MessageBoxResult]::Yes) {
                return
            }
        }

        Write-Progress-Logger "Running pre-Sysprep cleanup..." 50

        # Run cleanup automatically
        Invoke-PreCloneCleanup

        Write-Progress-Logger "Checking Windows activation..." 70

        # Check Windows activation status
        try {
            $licensing = Get-WmiObject -Class SoftwareLicensingProduct | Where-Object { $_.PartialProductKey -and $_.LicenseStatus -eq 1 }
            if ($licensing) {
                Write-Logger "Windows is activated and ready for Sysprep" "INFO"
            }
            else {
                Write-Logger "Windows activation status unclear - proceed with caution" "WARNING"
            }
        }
        catch {
            Write-Logger "Could not check Windows activation status" "WARNING"
        }

        Write-Progress-Logger "System preparation completed" 100

        $message = "System preparation for Sysprep completed successfully!`n`n"
        $message += "The system is now ready for Sysprep. You can proceed to run Sysprep when ready."

        Write-Logger "System preparation for Sysprep completed" "INFO"
        [System.Windows.MessageBox]::Show($message, "WDCA - Preparation Complete", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Information)

    }
    catch {
        Write-Logger "Error during Sysprep preparation: $($_.Exception.Message)" "ERROR"
        [System.Windows.MessageBox]::Show("Error during preparation: $($_.Exception.Message)", "WDCA - Preparation Error", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Error)
    }
    finally {
        # Reset progress bar
        if ($sync.WPFProgressBar) {
            $sync.WPFProgressBar.Dispatcher.Invoke([action]{
                $sync.WPFProgressBar.Value = 0
            })
        }
    }
}

function Invoke-SystemDiagnosticsAsync {
    <#
    .SYNOPSIS
        Runs system diagnostic scans in correct dependency order: DISM â†’ SFC â†’ CHKDSK
    .DESCRIPTION
        Executes all diagnostic scans sequentially in a single terminal window.
        Follows best practice order: DISM repairs Windows image, then SFC checks system files, then CHKDSK checks disk.
    #>

    Write-Logger "Starting comprehensive system diagnostics (sequential execution)" "INFO"

    try {
        # Show initial confirmation dialog
        $result = [System.Windows.MessageBox]::Show(
            "This will run all system diagnostic scans in the correct order:`n`n" +
            "1. DISM - Repairs Windows image (foundation)`n" +
            "2. SFC - Checks system files (depends on DISM)`n" +
            "3. CHKDSK - Checks disk health (independent)`n`n" +
            "All scans will run sequentially in one terminal window.`n" +
            "Total estimated time: 20-60 minutes`n`n" +
            "Continue with sequential system diagnostics?",
            "WDCA - Sequential System Diagnostics",
            [System.Windows.MessageBoxButton]::YesNo,
            [System.Windows.MessageBoxImage]::Question
        )

        if ($result -eq [System.Windows.MessageBoxResult]::No) {
            Write-Logger "Sequential system diagnostics cancelled by user" "INFO"
            return
        }

        Write-Logger "User confirmed: Starting sequential diagnostics in single window (DISMâ†’SFCâ†’CHKDSK)" "INFO"

        # Create combined script that runs all scans sequentially
        $tempScriptPath = Join-Path $env:TEMP "WDCA_Combined_Diagnostics.ps1"
        $logPath = Join-Path $env:TEMP "wdca_combined_diagnostics.log"
        $systemDrive = $env:SystemDrive

        $combinedScript = @"
# Terminal styling
`$Host.UI.RawUI.BackgroundColor = "Black"
`$Host.UI.RawUI.ForegroundColor = "White"
Clear-Host

# Combined logging function
function Write-DiagLog {
    param([string]`$Message, [string]`$Level = "INFO")
    try {
        `$timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        Add-Content -Path "$logPath" -Value "[`$timestamp] [`$Level] `$Message" -Encoding UTF8 -ErrorAction SilentlyContinue
    } catch { }
}

# Header
Write-Host ("=" * 60) -ForegroundColor Cyan
Write-Host "    WDCA Complete System Diagnostics Suite" -ForegroundColor Cyan
Write-Host ("=" * 60) -ForegroundColor Cyan
Write-Host ""

Write-DiagLog "Combined diagnostics session started" "INFO"
Write-Host "[INFO] Running sequential system diagnostics: DISM -> SFC -> CHKDSK" -ForegroundColor Cyan
Write-Host "[INFO] Estimated total time: 20-60 minutes" -ForegroundColor Cyan
Write-Host ""

try {
    `$overallStopwatch = [System.Diagnostics.Stopwatch]::StartNew()

    # Step 1: DISM Operations
    Write-Host ("=" * 50) -ForegroundColor Yellow
    Write-Host "  Step 1/3: DISM Image Repair" -ForegroundColor Yellow
    Write-Host ("=" * 50) -ForegroundColor Yellow
    Write-DiagLog "Starting DISM operations" "INFO"

    # DISM CheckHealth
    Write-Host ""
    Write-Host "[DISM] Step 1a: Quick Health Check" -ForegroundColor Cyan
    Write-Host ("-" * 30) -ForegroundColor DarkGray
    Write-DiagLog "Running: DISM /Online /Cleanup-Image /CheckHealth" "INFO"
    `$dismCheck = Start-Process -FilePath "dism.exe" -ArgumentList "/Online", "/Cleanup-Image", "/CheckHealth" -Wait -PassThru -NoNewWindow
    Write-Host "[DISM] CheckHealth completed (Exit: `$(`$dismCheck.ExitCode))" -ForegroundColor Gray

    # DISM ScanHealth
    Write-Host ""
    Write-Host "[DISM] Step 1b: Detailed Health Scan" -ForegroundColor Cyan
    Write-Host ("-" * 30) -ForegroundColor DarkGray
    Write-DiagLog "Running: DISM /Online /Cleanup-Image /ScanHealth" "INFO"
    `$dismScan = Start-Process -FilePath "dism.exe" -ArgumentList "/Online", "/Cleanup-Image", "/ScanHealth" -Wait -PassThru -NoNewWindow
    Write-Host "[DISM] ScanHealth completed (Exit: `$(`$dismScan.ExitCode))" -ForegroundColor Gray

    # DISM RestoreHealth
    Write-Host ""
    Write-Host "[DISM] Step 1c: Image Repair" -ForegroundColor Cyan
    Write-Host ("-" * 30) -ForegroundColor DarkGray
    Write-DiagLog "Running: DISM /Online /Cleanup-Image /RestoreHealth" "INFO"
    `$dismRestore = Start-Process -FilePath "dism.exe" -ArgumentList "/Online", "/Cleanup-Image", "/RestoreHealth" -Wait -PassThru -NoNewWindow
    Write-Host "[DISM] RestoreHealth completed (Exit: `$(`$dismRestore.ExitCode))" -ForegroundColor Gray

    Write-Host ""
    if (`$dismCheck.ExitCode -eq 0 -and `$dismScan.ExitCode -eq 0 -and `$dismRestore.ExitCode -eq 0) {
        Write-Host "[SUCCESS] DISM operations completed successfully" -ForegroundColor Green
        Write-DiagLog "DISM completed successfully" "SUCCESS"
    } else {
        Write-Host "[WARNING] DISM completed with some issues" -ForegroundColor Yellow
        Write-DiagLog "DISM completed with issues" "WARNING"
    }

    Write-Host ""
    Write-Host "Waiting 5 seconds before SFC..." -ForegroundColor DarkGray
    Start-Sleep -Seconds 5

    # Step 2: SFC Operation
    Write-Host ("=" * 50) -ForegroundColor Yellow
    Write-Host "  Step 2/3: SFC System File Check" -ForegroundColor Yellow
    Write-Host ("=" * 50) -ForegroundColor Yellow
    Write-DiagLog "Starting SFC scan" "INFO"

    Write-Host ""
    Write-Host "[SFC] Scanning system files..." -ForegroundColor Cyan
    Write-Host ("-" * 30) -ForegroundColor DarkGray
    Write-DiagLog "Running: sfc.exe /scannow" "INFO"
    `$sfcProcess = Start-Process -FilePath "sfc.exe" -ArgumentList "/scannow" -Wait -PassThru -NoNewWindow

    Write-Host ""
    switch (`$sfcProcess.ExitCode) {
        0 {
            Write-Host "[SUCCESS] SFC completed - No issues found" -ForegroundColor Green
            Write-DiagLog "SFC completed successfully" "SUCCESS"
        }
        1 {
            Write-Host "[SUCCESS] SFC found and repaired files" -ForegroundColor Green
            Write-DiagLog "SFC found and repaired issues" "SUCCESS"
        }
        2 {
            Write-Host "[WARNING] SFC completed - Restart required" -ForegroundColor Yellow
            Write-DiagLog "SFC completed, restart required" "WARNING"
        }
        3 {
            Write-Host "[WARNING] SFC found unrepairable files" -ForegroundColor Yellow
            Write-DiagLog "SFC found unrepaired issues" "WARNING"
        }
        default {
            Write-Host "[WARNING] SFC completed with exit code `$(`$sfcProcess.ExitCode)" -ForegroundColor Yellow
            Write-DiagLog "SFC completed with exit code `$(`$sfcProcess.ExitCode)" "WARNING"
        }
    }

    Write-Host ""
    Write-Host "Waiting 5 seconds before CHKDSK..." -ForegroundColor DarkGray
    Start-Sleep -Seconds 5

    # Step 3: CHKDSK Operation
    Write-Host ("=" * 50) -ForegroundColor Yellow
    Write-Host "  Step 3/3: CHKDSK Disk Check" -ForegroundColor Yellow
    Write-Host ("=" * 50) -ForegroundColor Yellow
    Write-DiagLog "Starting CHKDSK scan on drive $systemDrive" "INFO"

    Write-Host ""
    Write-Host "[CHKDSK] Checking disk: $systemDrive" -ForegroundColor Cyan
    Write-Host ("-" * 30) -ForegroundColor DarkGray
    Write-DiagLog "Running: chkdsk $systemDrive /f /r" "INFO"
    `$chkdskProcess = Start-Process -FilePath "chkdsk.exe" -ArgumentList "$systemDrive", "/f", "/r" -Wait -PassThru -NoNewWindow

    Write-Host ""
    switch (`$chkdskProcess.ExitCode) {
        0 {
            Write-Host "[SUCCESS] CHKDSK completed - No errors found" -ForegroundColor Green
            Write-DiagLog "CHKDSK completed successfully" "SUCCESS"
        }
        1 {
            Write-Host "[SUCCESS] CHKDSK found and fixed errors" -ForegroundColor Green
            Write-DiagLog "CHKDSK found and fixed errors" "SUCCESS"
        }
        2 {
            Write-Host "[SCHEDULED] CHKDSK scheduled for next reboot" -ForegroundColor Yellow
            Write-Host "  System drive is in use - restart required" -ForegroundColor Yellow
            Write-DiagLog "CHKDSK scheduled for next reboot" "INFO"
        }
        default {
            Write-Host "[WARNING] CHKDSK completed with exit code `$(`$chkdskProcess.ExitCode)" -ForegroundColor Yellow
            Write-DiagLog "CHKDSK completed with exit code `$(`$chkdskProcess.ExitCode)" "WARNING"
        }
    }

    `$overallStopwatch.Stop()

    # Final Summary
    Write-Host ""
    Write-Host ("=" * 60) -ForegroundColor Cyan
    Write-Host "    DIAGNOSTICS COMPLETE" -ForegroundColor Cyan
    Write-Host ("=" * 60) -ForegroundColor Cyan

    Write-Host ""
    Write-Host "Summary of Results:" -ForegroundColor Yellow
    Write-Host "  DISM CheckHealth:   Exit Code `$(`$dismCheck.ExitCode)" -ForegroundColor Gray
    Write-Host "  DISM ScanHealth:    Exit Code `$(`$dismScan.ExitCode)" -ForegroundColor Gray
    Write-Host "  DISM RestoreHealth: Exit Code `$(`$dismRestore.ExitCode)" -ForegroundColor Gray
    Write-Host "  SFC Scan:           Exit Code `$(`$sfcProcess.ExitCode)" -ForegroundColor Gray
    Write-Host "  CHKDSK Scan:        Exit Code `$(`$chkdskProcess.ExitCode)" -ForegroundColor Gray
    Write-Host "  Total Duration:     `$(`$overallStopwatch.Elapsed.ToString("hh\:mm\:ss"))" -ForegroundColor Gray

    Write-Host ""
    # Overall system health assessment
    `$allGood = (`$dismCheck.ExitCode -eq 0 -and `$dismScan.ExitCode -eq 0 -and `$dismRestore.ExitCode -eq 0 -and `$sfcProcess.ExitCode -le 1 -and `$chkdskProcess.ExitCode -le 1)
    if (`$allGood) {
        Write-Host "Overall Status: SYSTEM HEALTHY" -ForegroundColor Green
        Write-DiagLog "All diagnostics completed successfully - system healthy" "SUCCESS"
    } else {
        Write-Host "Overall Status: ATTENTION REQUIRED" -ForegroundColor Yellow
        Write-DiagLog "Some diagnostics completed with issues" "WARNING"

        if (`$chkdskProcess.ExitCode -eq 2) {
            Write-Host "Action Required: Restart computer to complete CHKDSK" -ForegroundColor Cyan
        }
    }

}
catch {
    Write-Host "[ERROR] Critical error during diagnostics: `$(`$_.Exception.Message)" -ForegroundColor Red
    Write-DiagLog "Critical error: `$(`$_.Exception.Message)" "ERROR"
}

# Footer
Write-Host ""
Write-Host ("-" * 60) -ForegroundColor DarkGray
Write-Host "Log saved to: $logPath" -ForegroundColor Cyan
Write-DiagLog "Combined diagnostics session completed" "INFO"

Write-Host ""
Write-Host "Press any key to close..." -ForegroundColor Blue
`$null = `$Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
"@

        # Create and run the combined script
        Set-Content -Path $tempScriptPath -Value $combinedScript -Encoding UTF8
        Write-Logger "Created combined diagnostics script: $tempScriptPath" "INFO"

        $combinedProcess = Start-Process -FilePath "powershell.exe" -ArgumentList @(
            "-NoProfile"
            "-ExecutionPolicy", "Bypass"
            "-File", "`"$tempScriptPath`""
        ) -WindowStyle Normal -PassThru

        Write-Logger "Started combined diagnostics terminal (PID: $($combinedProcess.Id))" "SUCCESS"

        # Cleanup script after use
        Start-Job -ScriptBlock {
            param($ProcessId, $ScriptPath)
            try {
                $process = Get-Process -Id $ProcessId -ErrorAction SilentlyContinue
                if ($process) { $process.WaitForExit() }
                Start-Sleep -Seconds 5
                if (Test-Path $ScriptPath) {
                    Remove-Item $ScriptPath -Force -ErrorAction SilentlyContinue
                }
            } catch { }
        } -ArgumentList $combinedProcess.Id, $tempScriptPath | Out-Null

        # Show immediate completion message
        [System.Windows.MessageBox]::Show(
            "Sequential system diagnostics started!`n`n" +
            "All scans (DISM â†’ SFC â†’ CHKDSK) will run in one terminal window.`n`n" +
            "Log file: $logPath",
            "WDCA - Diagnostics Started",
            [System.Windows.MessageBoxButton]::OK,
            [System.Windows.MessageBoxImage]::Information
        )

    }
    catch {
        Write-Logger "Critical error in sequential diagnostics: $($_.Exception.Message)" "ERROR"
        [System.Windows.MessageBox]::Show(
            "A critical error occurred starting diagnostics:`n$($_.Exception.Message)",
            "WDCA - Critical Error",
            [System.Windows.MessageBoxButton]::OK,
            [System.Windows.MessageBoxImage]::Error
        )
    }
}

function Invoke-SystemSysprep {
    <#
    .SYNOPSIS
        Runs Windows Sysprep for system imaging

    .DESCRIPTION
        Executes Sysprep with user-selected options to prepare the system for imaging
    #>

    Write-Logger "Starting Sysprep process" "INFO"

    # Get Sysprep options from UI
    $generalize = if ($sync.WPFSysprepGeneralize) { $sync.WPFSysprepGeneralize.IsChecked } else { $true }
    $oobe = if ($sync.WPFSysprepOOBE) { $sync.WPFSysprepOOBE.IsChecked } else { $true }
    $shutdown = if ($sync.WPFSysprepShutdown) { $sync.WPFSysprepShutdown.IsChecked } else { $true }

    # Build Sysprep command arguments
    $sysprepArgs = @("/quiet")

    if ($generalize) {
        $sysprepArgs += "/generalize"
    }

    if ($oobe) {
        $sysprepArgs += "/oobe"
    }
    else {
        $sysprepArgs += "/audit"
    }

    if ($shutdown) {
        $sysprepArgs += "/shutdown"
    }
    else {
        $sysprepArgs += "/reboot"
    }

    # Show final warning
    $warningMessage = "CRITICAL WARNING`n`n"
    $warningMessage += "Sysprep will prepare this system for imaging and will:`n`n"
    if ($generalize) { $warningMessage += "- Remove system-specific information (Generalize)`n" }
    if ($oobe) { $warningMessage += "- Boot to Out-of-Box Experience on next start`n" }
    if ($shutdown) { $warningMessage += "- Shutdown the computer when complete`n" } else { $warningMessage += "- Restart the computer when complete`n" }
    $warningMessage += "`n This action CANNOT be undone!`n`n"
    $warningMessage += "Command: sysprep.exe $($sysprepArgs -join ' ')`n`n"
    $warningMessage += "Continue with Sysprep?"

    $confirmResult = [System.Windows.MessageBox]::Show(
        $warningMessage,
        "WDCA - Sysprep Warning",
        [System.Windows.MessageBoxButton]::YesNo,
        [System.Windows.MessageBoxImage]::Warning
    )

    if ($confirmResult -ne [System.Windows.MessageBoxResult]::Yes) {
        Write-Logger "Sysprep cancelled by user" "INFO"
        return
    }

    try {
        Write-Logger "Running Sysprep with arguments: $($sysprepArgs -join ' ')" "INFO"
        Write-Progress-Logger "Preparing system for imaging..." 50

        # Run Sysprep
        $sysprepPath = "$env:SystemRoot\System32\Sysprep\sysprep.exe"

        if (-not (Test-Path $sysprepPath)) {
            throw "Sysprep.exe not found at $sysprepPath"
        }

        Write-Logger "Executing Sysprep - System will shutdown/restart when complete" "INFO"

        # Start Sysprep process
        Start-Process -FilePath $sysprepPath -ArgumentList $sysprepArgs -NoNewWindow

        Write-Logger "Sysprep process started successfully" "INFO"
        [System.Windows.MessageBox]::Show("Sysprep has been started. The system will shutdown or restart when the process completes.", "WDCA - Sysprep Started", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Information)

    }
    catch {
        Write-Logger "Error running Sysprep: $($_.Exception.Message)" "ERROR"
        [System.Windows.MessageBox]::Show("Error running Sysprep: $($_.Exception.Message)", "WDCA - Sysprep Error", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Error)
    }
    finally {
        # Reset progress bar
        if ($sync.WPFProgressBar) {
            $sync.WPFProgressBar.Dispatcher.Invoke([action]{
                $sync.WPFProgressBar.Value = 0
            })
        }
    }
}

function Invoke-WPFApplicationsAsync {
    <#
    .SYNOPSIS
        WinGet Installation in neuem Terminal-Fenster
    #>

    Write-Logger "Starting WinGet installation in new terminal" "INFO"

    # AusgewÃ¤hlte Apps sammeln
    $selectedApps = @()
    if ($sync.configs.applications) {
        foreach ($app in $sync.configs.applications.PSObject.Properties) {
            $checkboxName = $app.Name
            if ($sync[$checkboxName] -and $sync[$checkboxName].IsChecked -eq $true) {
                $selectedApps += @{
                    Name        = $checkboxName
                    DisplayName = $app.Value.content
                    WingetId    = $app.Value.winget
                    Description = $app.Value.description
                }
            }
        }
    }

    if ($selectedApps.Count -eq 0) {
        Write-Logger "No applications selected for installation" "WARNING"
        [System.Windows.MessageBox]::Show("Please select at least one application to install.", "WDCA - No Selection", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Information)
        return
    }

    # BestÃ¤tigung
    $confirmResult = [System.Windows.MessageBox]::Show(
        "Install $($selectedApps.Count) selected applications?`n`nInstallation will start in a new terminal window.",
        "WDCA - Confirm Installation",
        [System.Windows.MessageBoxButton]::YesNo,
        [System.Windows.MessageBoxImage]::Question
    )

    if ($confirmResult -ne [System.Windows.MessageBoxResult]::Yes) {
        Write-Logger "Application installation cancelled by user" "INFO"
        return
    }

    # WinGet test
    try {
        Write-Logger "Testing WinGet availability..." "INFO"
        $wingetTest = Start-Process -FilePath "winget" -ArgumentList "--version" -Wait -PassThru -WindowStyle Hidden
        if ($wingetTest.ExitCode -ne 0) {
            throw "WinGet not working properly"
        }
        Write-Logger "WinGet test successful" "INFO"
    }
    catch {
        Write-Logger "WinGet test failed: $($_.Exception.Message)" "ERROR"
        [System.Windows.MessageBox]::Show("WinGet is not working properly. Please ensure WinGet is installed and accessible.", "WDCA - WinGet Error", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Error)
        return
    }

    # TemporÃ¤res PowerShell-Script erstellen
    $tempScriptPath = Join-Path $env:TEMP "WDCA_WinGet_Install.ps1"

    $scriptContent = @"
# WDCA WinGet Installation Script
# Terminal-Design: Schwarz/WeiÃŸ und kompakt
`$Host.UI.RawUI.BackgroundColor = "Black"
`$Host.UI.RawUI.ForegroundColor = "White"
Clear-Host

Write-Host "WDCA WinGet Installer" -ForegroundColor White
Write-Host "Apps: $($selectedApps.Count) | " -ForegroundColor White -NoNewline
Write-Host "Starting..." -ForegroundColor White
Write-Host ("-" * 50) -ForegroundColor DarkGray

function Write-InstallLog {
    param([string]`$Message, [string]`$Level = "INFO")
    try {
        `$timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        `$logEntry = "[`$timestamp] [`$Level] [Install] `$Message"
        Add-Content -Path "$($global:sync.logFile)" -Value `$logEntry -Encoding UTF8 -ErrorAction SilentlyContinue
    }
    catch {
        # Silent fail for logging
    }
}

Write-InstallLog "=== Starting Installation in new terminal ===" "INFO"

"@

    # Apps zur Installation hinzufÃ¼gen
    foreach ($app in $selectedApps) {
        $scriptContent += @"

Write-Host "Installing $($app.DisplayName)..." -ForegroundColor White -NoNewline
Write-InstallLog "Installing: $($app.DisplayName) (ID: $($app.WingetId))" "INFO"

try {
    `$installArgs = @(
        "install"
        "--id"
        "$($app.WingetId)"
        "--silent"
        "--accept-source-agreements"
        "--accept-package-agreements"
        "--force"
    )

    # WinGet ausfÃ¼hren
    & winget @installArgs | Out-Null

    `$exitCode = `$LASTEXITCODE

    if (`$exitCode -eq 0) {
        Write-Host " OK" -ForegroundColor White
        Write-InstallLog "SUCCESS: $($app.DisplayName)" "SUCCESS"
    }
    else {
        Write-Host " FAILED (`$exitCode)" -ForegroundColor White
        Write-InstallLog "FAILED: $($app.DisplayName) - Exit Code: `$exitCode" "ERROR"
    }
}
catch {
    Write-Host " ERROR" -ForegroundColor White
    Write-InstallLog "EXCEPTION: $($app.DisplayName) - `$(`$_.Exception.Message)" "ERROR"
}

Start-Sleep -Milliseconds 200

"@
    }

    $scriptContent += @"

Write-Host ("-" * 50) -ForegroundColor DarkGray
Write-Host "Installation completed" -ForegroundColor White
Write-InstallLog "=== Installation Completed ===" "INFO"
Write-Host "Press any key to close..." -ForegroundColor White
`$null = `$Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")

"@

    try {
        # Script in Temp-Datei schreiben
        Set-Content -Path $tempScriptPath -Value $scriptContent -Encoding UTF8
        Write-Logger "Created temporary installation script: $tempScriptPath" "INFO"

        # Neues PowerShell-Terminal starten
        $processArgs = @{
            FilePath     = "powershell.exe"
            ArgumentList = @(
                "-NoProfile"
                "-ExecutionPolicy", "Bypass"
                "-File", "`"$tempScriptPath`""
            )
            WindowStyle  = "Normal"
            PassThru     = $true
        }

        $installProcess = Start-Process @processArgs
        Write-Logger "Started installation in new terminal (PID: $($installProcess.Id))" "SUCCESS"

        # Cleanup-Timer fÃ¼r das temporÃ¤re Script
        $cleanupTimer = New-Object System.Windows.Threading.DispatcherTimer
        $cleanupTimer.Interval = [TimeSpan]::FromSeconds(10)

        $cleanupTimer.Add_Tick({
                try {
                    if ($installProcess.HasExited) {
                        # TemporÃ¤res Script lÃ¶schen
                        if (Test-Path $tempScriptPath) {
                            Remove-Item $tempScriptPath -Force -ErrorAction SilentlyContinue
                            Write-Logger "Cleaned up temporary script" "INFO"
                        }
                        $cleanupTimer.Stop()
                    }
                }
                catch {
                    Write-Logger "Cleanup error: $($_.Exception.Message)" "ERROR"
                    $cleanupTimer.Stop()
                }
            })

        $cleanupTimer.Start()
    }
    catch {
        Write-Logger "Error starting installation terminal: $($_.Exception.Message)" "ERROR"
        [System.Windows.MessageBox]::Show(
            "Failed to start installation in new terminal: $($_.Exception.Message)",
            "WDCA - Terminal Error",
            [System.Windows.MessageBoxButton]::OK,
            [System.Windows.MessageBoxImage]::Error
        )
    }
}

function Invoke-WPFCloning {
    <#
    .SYNOPSIS
        Handles system cloning and imaging preparation

    .DESCRIPTION
        Prepares systems for cloning using Sysprep and cleanup operations

    .PARAMETER Action
        The cloning action to perform

    .EXAMPLE
        Invoke-WPFCloning -Action "Sysprep"
        Invoke-WPFCloning -Action "Cleanup"
    #>

    param(
        [Parameter(Mandatory = $true)]
        [ValidateSet("Sysprep", "Cleanup", "Prepare")]
        [string]$Action
    )

    Write-Logger "Starting cloning action: $Action" "INFO"

    switch ($Action) {
        "Sysprep" {
            Invoke-SystemSysprep
        }
        "Cleanup" {
            Invoke-PreCloneCleanup
        }
        "Prepare" {
            Invoke-SysprepPreparation
        }
    }
}

function Invoke-WPFListAppUpdates {
    <#
    .SYNOPSIS
        Lists available application updates in a new terminal window
    #>

    Write-Logger "Starting application update check in new terminal" "INFO"

    $tempScriptPath = Join-Path $env:TEMP "WDCA_AppUpdate_Check.ps1"
    $logPath = Join-Path $env:TEMP "wdca_app_updates.log"

    $scriptContent = @"
# Terminal styling
`$Host.UI.RawUI.BackgroundColor = "Black"
`$Host.UI.RawUI.ForegroundColor = "White"
Clear-Host

# Header
Write-Host ("=" * 60) -ForegroundColor Cyan
Write-Host "  WDCA Application Update Scanner" -ForegroundColor Cyan
Write-Host ("=" * 60) -ForegroundColor Cyan
Write-Host ""

Write-Host "[INFO] Scanning for available application updates..." -ForegroundColor Cyan
Write-Host ""

try {
    # Run winget upgrade
    Write-Host "[INFO] Running: winget upgrade --include-unknown" -ForegroundColor Cyan
    `$wingetOutput = winget upgrade --include-unknown 2>&1

    if (`$wingetOutput) {
        Write-Host "[SUCCESS] Scan completed" -ForegroundColor Green
        Write-Host ""

        Write-Host ("=" * 60) -ForegroundColor Cyan
        Write-Host "  WINGET OUTPUT" -ForegroundColor Cyan
        Write-Host ("=" * 60) -ForegroundColor Cyan
        Write-Host ""

        # Show the output with better formatting
        `$updateCount = 0
        `$apps = @()

        Write-Host ("=" * 60) -ForegroundColor Cyan
        Write-Host "  AVAILABLE UPDATES" -ForegroundColor Cyan
        Write-Host ("=" * 60) -ForegroundColor Cyan
        Write-Host ""

        foreach (`$line in `$wingetOutput) {
            # Update entries (in table and containing version numbers)
            if (`$line -match "^[A-Z].*[\d\.].*[\d\.].*winget" -and `$line -notmatch "Name.*Version") {
                `$updateCount++
                # Extract app name and ID for examples
                if (`$line -match "(\S+\.\S+)") {
                    `$apps += `$matches[1]
                }
                Write-Host "[`$updateCount] `$line" -ForegroundColor Green
            }
            # Explicit targeting section
            elseif (`$line -match "^[A-Za-z].*Discord|^Discord") {
                `$updateCount++
                `$apps += "Discord.Discord"
                Write-Host "[`$updateCount] `$line (requires --id)" -ForegroundColor Yellow
            }
        }

        Write-Host ""
        Write-Host ("=" * 60) -ForegroundColor Green
        Write-Host "  SUMMARY" -ForegroundColor Green
        Write-Host ("=" * 60) -ForegroundColor Green
        Write-Host ""

        if (`$updateCount -gt 0) {
            Write-Host "Found `$updateCount application(s) ready to update" -ForegroundColor Green
        } else {
            Write-Host "All applications are up to date" -ForegroundColor Green
        }

        Write-Host ""
        Write-Host ("=" * 60) -ForegroundColor Yellow
        Write-Host "  QUICK ACTIONS" -ForegroundColor Yellow
        Write-Host ("=" * 60) -ForegroundColor Yellow
        Write-Host ""
        Write-Host "Update all:        winget upgrade --all" -ForegroundColor Cyan
        Write-Host "Update silently:   winget upgrade --all --silent" -ForegroundColor Cyan
        Write-Host ""

        if (`$apps.Count -gt 0) {
            Write-Host "Update examples:" -ForegroundColor White
            `$examples = `$apps | Select-Object -First 2
            foreach (`$app in `$examples) {
                Write-Host "  winget upgrade --id `$app" -ForegroundColor Cyan
            }
        }

        Write-Host ""
        Write-Host "Tip: Run as Administrator for best results" -ForegroundColor DarkYellow
    }
    else {
        Write-Host "[ERROR] No output from WinGet" -ForegroundColor Red
    }
}
catch {
    Write-Host "[ERROR] Failed to run WinGet: `$(`$_.Exception.Message)" -ForegroundColor Red
}

Write-Host ""
Write-Host "Press any key to close..." -ForegroundColor Blue
`$null = `$Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
"@

    # Create and run script
    try {
        Set-Content -Path $tempScriptPath -Value $scriptContent -Encoding UTF8
        Write-Logger "Created app update check script: $tempScriptPath" "INFO"

        $updateProcess = Start-Process -FilePath "powershell.exe" -ArgumentList @(
            "-NoProfile"
            "-ExecutionPolicy", "Bypass"
            "-File", "`"$tempScriptPath`""
        ) -WindowStyle Normal -PassThru

        Write-Logger "Started app update check terminal (PID: $($updateProcess.Id))" "SUCCESS"

        # Cleanup script after use
        Start-Job -ScriptBlock {
            param($ProcessId, $ScriptPath)
            try {
                $process = Get-Process -Id $ProcessId -ErrorAction SilentlyContinue
                if ($process) { $process.WaitForExit() }
                Start-Sleep -Seconds 5
                if (Test-Path $ScriptPath) {
                    Remove-Item $ScriptPath -Force -ErrorAction SilentlyContinue
                }
            } catch { }
        } -ArgumentList $updateProcess.Id, $tempScriptPath | Out-Null

    }
    catch {
        Write-Logger "Failed to start app update check: $($_.Exception.Message)" "ERROR"
        [System.Windows.MessageBox]::Show(
            "Failed to start application update check.`n$($_.Exception.Message)",
            "WDCA - Update Check Error",
            [System.Windows.MessageBoxButton]::OK,
            [System.Windows.MessageBoxImage]::Error
        )

        if (Test-Path $tempScriptPath) {
            Remove-Item $tempScriptPath -Force -ErrorAction SilentlyContinue
        }
    }
}

function Invoke-WPFSystemSetup {
    <#
    .SYNOPSIS
        Handles system configuration tasks

    .DESCRIPTION
        Configures network settings, enables RDP, and applies server roles

    .PARAMETER Action
        The configuration action to perform (Network, RDP, Role)

    .EXAMPLE
        Invoke-WPFSystemSetup -Action "Network"
        Invoke-WPFSystemSetup -Action "RDP"
        Invoke-WPFSystemSetup -Action "Role"
    #>

    param(
        [Parameter(Mandatory = $true)]
        [ValidateSet("Network", "RDP", "Role")]
        [string]$Action
    )

    Write-Logger "Starting system setup action: $Action" "INFO"

    switch ($Action) {
        "Network" {
            Invoke-NetworkConfiguration
        }
        "RDP" {
            Invoke-RDPConfiguration
        }
    }
}

function Invoke-WPFTroubleshooting {
    <#
    .SYNOPSIS
        Handles system diagnostics and troubleshooting

    .DESCRIPTION
        Runs various system diagnostic tools and network tests

    .PARAMETER Action
        The troubleshooting action to perform

    .EXAMPLE
        Invoke-WPFTroubleshooting -Action "SystemDiagnostics"
        Invoke-WPFTroubleshooting -Action "NetworkDiagnostics"
    #>

    param(
        [Parameter(Mandatory = $true)]
        [ValidateSet("SystemDiagnostics", "NetworkDiagnostics", "DISM", "SFC", "CHKDSK")]
        [string]$Action
    )

    Write-Logger "Starting troubleshooting action: $Action" "INFO"

    switch ($Action) {
        "SystemDiagnostics" {
            Invoke-SystemDiagnosticsAsync
        }
        "DISM" {
            Invoke-DISMScan
        }
        "SFC" {
            Invoke-SFCScan
        }
        "CHKDSK" {
            Invoke-CHKDSKScan
        }
    }
}

function Invoke-WPFUpdateApps {
    <#
    .SYNOPSIS
        Updates all available applications in a new terminal window
    #>

    Write-Logger "Starting application updates in new terminal" "INFO"

    # Show confirmation dialog
    $confirmResult = [System.Windows.MessageBox]::Show(
        "This will update all applications using WinGet.`n`n" +
        "Continue with application updates?",
        "WDCA - Confirm Application Updates",
        [System.Windows.MessageBoxButton]::YesNo,
        [System.Windows.MessageBoxImage]::Question
    )

    if ($confirmResult -ne [System.Windows.MessageBoxResult]::Yes) {
        Write-Logger "Application updates cancelled by user" "INFO"
        return
    }

    $tempScriptPath = Join-Path $env:TEMP "WDCA_AppUpdate_Install.ps1"

    $scriptContent = @"
# Terminal styling
`$Host.UI.RawUI.BackgroundColor = "Black"
`$Host.UI.RawUI.ForegroundColor = "White"
Clear-Host

# Header
Write-Host ("=" * 60) -ForegroundColor Cyan
Write-Host "  WDCA Application Update Installer" -ForegroundColor Cyan
Write-Host ("=" * 60) -ForegroundColor Cyan
Write-Host ""

Write-Host "[INFO] Starting application update process..." -ForegroundColor Cyan
Write-Host ""

try {
    # Check WinGet
    Write-Host "[INFO] Checking WinGet availability..." -ForegroundColor Cyan
    `$wingetVersion = winget --version
    Write-Host "[SUCCESS] WinGet available - Version: `$wingetVersion" -ForegroundColor Green
    Write-Host ""

    # Run the update
    Write-Host "[INFO] Running: winget upgrade --all --silent --accept-source-agreements --accept-package-agreements" -ForegroundColor Cyan
    Write-Host ""

    `$startTime = Get-Date

    # Execute the upgrade command and show output in real-time
    winget upgrade --all --silent --accept-source-agreements --accept-package-agreements

    `$endTime = Get-Date
    `$duration = (`$endTime - `$startTime).ToString("mm\:ss")

    Write-Host ""
    Write-Host ("=" * 60) -ForegroundColor Green
    Write-Host "  UPDATE PROCESS COMPLETED" -ForegroundColor Green
    Write-Host ("=" * 60) -ForegroundColor Green
    Write-Host ""
    Write-Host "[SUMMARY] Update process completed in `$duration" -ForegroundColor Cyan
    Write-Host "[SUMMARY] Check output above for individual app results" -ForegroundColor Cyan
    Write-Host ""
    Write-Host "[RECOMMENDATION] Restart applications to use new versions" -ForegroundColor Yellow
    Write-Host "[RECOMMENDATION] Consider restarting Windows if system components were updated" -ForegroundColor Yellow

}
catch {
    Write-Host "[ERROR] Update process failed: `$(`$_.Exception.Message)" -ForegroundColor Red
}

Write-Host ""
Write-Host "Press any key to close..." -ForegroundColor Blue
`$null = `$Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
"@

    # Create and run script
    try {
        Set-Content -Path $tempScriptPath -Value $scriptContent -Encoding UTF8
        Write-Logger "Created app update install script: $tempScriptPath" "INFO"

        $updateProcess = Start-Process -FilePath "powershell.exe" -ArgumentList @(
            "-NoProfile"
            "-ExecutionPolicy", "Bypass"
            "-File", "`"$tempScriptPath`""
        ) -WindowStyle Normal -PassThru

        Write-Logger "Started app update install terminal (PID: $($updateProcess.Id))" "SUCCESS"

        # Show immediate confirmation
        [System.Windows.MessageBox]::Show(
            "Application update process started!`n`n" +
            "Updates will be installed in the new terminal window.",
            "WDCA - Updates Started",
            [System.Windows.MessageBoxButton]::OK,
            [System.Windows.MessageBoxImage]::Information
        )

        # Cleanup script after use
        Start-Job -ScriptBlock {
            param($ProcessId, $ScriptPath)
            try {
                $process = Get-Process -Id $ProcessId -ErrorAction SilentlyContinue
                if ($process) { $process.WaitForExit() }
                Start-Sleep -Seconds 5
                if (Test-Path $ScriptPath) {
                    Remove-Item $ScriptPath -Force -ErrorAction SilentlyContinue
                }
            } catch { }
        } -ArgumentList $updateProcess.Id, $tempScriptPath | Out-Null

    }
    catch {
        Write-Logger "Failed to start app updates: $($_.Exception.Message)" "ERROR"
        [System.Windows.MessageBox]::Show(
            "Failed to start application updates.`n$($_.Exception.Message)",
            "WDCA - Update Error",
            [System.Windows.MessageBoxButton]::OK,
            [System.Windows.MessageBoxImage]::Error
        )

        if (Test-Path $tempScriptPath) {
            Remove-Item $tempScriptPath -Force -ErrorAction SilentlyContinue
        }
    }
}

function Test-RebootRequired {
    <#
    .SYNOPSIS
        Checks if a system reboot is required

    .DESCRIPTION
        Checks various registry locations and file indicators for pending reboots

    .EXAMPLE
        Test-RebootRequired
    #>

    $rebootRequired = $false
    $reasons = @()

    try {
        # Check Windows Update reboot flag
        $wuReboot = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired" -ErrorAction SilentlyContinue
        if ($wuReboot) {
            $rebootRequired = $true
            $reasons += "Windows Update"
        }

        # Check Component Based Servicing reboot flag
        $cbsReboot = Get-ChildItem -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending" -ErrorAction SilentlyContinue
        if ($cbsReboot) {
            $rebootRequired = $true
            $reasons += "Component Based Servicing"
        }

        # Check pending file rename operations
        $pendingFileRename = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name "PendingFileRenameOperations" -ErrorAction SilentlyContinue
        if ($pendingFileRename) {
            $rebootRequired = $true
            $reasons += "Pending File Rename Operations"
        }

        if ($rebootRequired) {
            Write-Logger "Reboot required. Reasons: $($reasons -join ', ')" "WARNING"
            return @{
                Required = $true
                Reasons = $reasons
            }
        }
        else {
            Write-Logger "No reboot required" "INFO"
            return @{
                Required = $false
                Reasons = @()
            }
        }
    }
    catch {
        Write-Logger "Error checking reboot requirement: $($_.Exception.Message)" "ERROR"
        return @{
            Required = $false
            Reasons = @()
        }
    }
}

$sync.configs.applications = ConvertFrom-Json @'
{
    "WPFInstall1password":  {
                                "category":  "Utilities",
                                "content":  "1Password",
                                "description":  "1Password is a password manager that allows you to store and manage your passwords securely.",
                                "link":  "https://1password.com/",
                                "winget":  "AgileBits.1Password"
                            },
    "WPFInstalladobe":  {
                            "category":  "Document",
                            "content":  "Adobe Acrobat Reader",
                            "description":  "Adobe Acrobat Reader is a free PDF viewer with essential features for viewing, printing, and annotating PDF documents.",
                            "link":  "https://www.adobe.com/acrobat/pdf-reader.html",
                            "winget":  "Adobe.Acrobat.Reader.64-bit"
                        },
    "WPFInstalladvancedip":  {
                                 "category":  "Pro Tools",
                                 "content":  "Advanced IP Scanner",
                                 "description":  "Advanced IP Scanner is a fast and easy-to-use network scanner. It is designed to analyze LAN networks and provides information about connected devices.",
                                 "link":  "https://www.advanced-ip-scanner.com/",
                                 "winget":  "Famatech.AdvancedIPScanner"
                             },
    "WPFInstallbrave":  {
                            "category":  "Browsers",
                            "content":  "Brave",
                            "description":  "Brave is a privacy-focused web browser that blocks ads and trackers, offering a faster and safer browsing experience.",
                            "link":  "https://www.brave.com",
                            "winget":  "Brave.Brave"
                        },
    "WPFInstallchrome":  {
                             "category":  "Browsers",
                             "content":  "Chrome",
                             "description":  "Google Chrome is a widely used web browser known for its speed, simplicity, and seamless integration with Google services.",
                             "link":  "https://www.google.com/chrome/",
                             "winget":  "Google.Chrome"
                         },
    "WPFInstallfirefox":  {
                              "category":  "Browsers",
                              "content":  "Firefox",
                              "description":  "Mozilla Firefox is an open-source web browser known for its customization options, privacy features, and extensions.",
                              "link":  "https://www.mozilla.org/en-US/firefox/new/",
                              "winget":  "Mozilla.Firefox"
                          },
    "WPFInstallcrystaldiskinfo":  {
                                      "category":  "Utilities",
                                      "content":  "Crystal Disk Info",
                                      "description":  "Crystal Disk Info is a disk health monitoring tool that provides information about the status and performance of hard drives. It helps users anticipate potential issues and monitor drive health.",
                                      "link":  "https://crystalmark.info/en/software/crystaldiskinfo/",
                                      "winget":  "CrystalDewWorld.CrystalDiskInfo"
                                  },
    "WPFInstallcrystaldiskmark":  {
                                      "category":  "Utilities",
                                      "content":  "Crystal Disk Mark",
                                      "description":  "Crystal Disk Mark is a disk benchmarking tool that measures the read and write speeds of storage devices. It helps users assess the performance of their hard drives and SSDs.",
                                      "link":  "https://crystalmark.info/en/software/crystaldiskmark/",
                                      "winget":  "CrystalDewWorld.CrystalDiskMark"
                                  },
    "WPFInstalldotnet3":  {
                              "category":  "Microsoft Tools",
                              "content":  ".NET Desktop Runtime 3.1",
                              "description":  ".NET Desktop Runtime 3.1 is a runtime environment required for running applications developed with .NET Core 3.1.",
                              "link":  "https://dotnet.microsoft.com/download/dotnet/3.1",
                              "winget":  "Microsoft.DotNet.DesktopRuntime.3_1"
                          },
    "WPFInstalldotnet5":  {
                              "category":  "Microsoft Tools",
                              "content":  ".NET Desktop Runtime 5",
                              "description":  ".NET Desktop Runtime 5 is a runtime environment required for running applications developed with .NET 5.",
                              "link":  "https://dotnet.microsoft.com/download/dotnet/5.0",
                              "winget":  "Microsoft.DotNet.DesktopRuntime.5"
                          },
    "WPFInstalldotnet6":  {
                              "category":  "Microsoft Tools",
                              "content":  ".NET Desktop Runtime 6",
                              "description":  ".NET Desktop Runtime 6 is a runtime environment required for running applications developed with .NET 6.",
                              "link":  "https://dotnet.microsoft.com/download/dotnet/6.0",
                              "winget":  "Microsoft.DotNet.DesktopRuntime.6"
                          },
    "WPFInstalldotnet7":  {
                              "category":  "Microsoft Tools",
                              "content":  ".NET Desktop Runtime 7",
                              "description":  ".NET Desktop Runtime 7 is a runtime environment required for running applications developed with .NET 7.",
                              "link":  "https://dotnet.microsoft.com/download/dotnet/7.0",
                              "winget":  "Microsoft.DotNet.DesktopRuntime.7"
                          },
    "WPFInstalldotnet8":  {
                              "category":  "Microsoft Tools",
                              "content":  ".NET Desktop Runtime 8",
                              "description":  ".NET Desktop Runtime 8 is a runtime environment required for running applications developed with .NET 8.",
                              "link":  "https://dotnet.microsoft.com/download/dotnet/8.0",
                              "winget":  "Microsoft.DotNet.DesktopRuntime.8"
                          },
    "WPFInstalldotnet9":  {
                              "category":  "Microsoft Tools",
                              "content":  ".NET Desktop Runtime 9",
                              "description":  ".NET Desktop Runtime 9 is a runtime environment required for running applications developed with .NET 9.",
                              "link":  "https://dotnet.microsoft.com/download/dotnet/9.0",
                              "winget":  "Microsoft.DotNet.DesktopRuntime.9"
                          },
    "WPFInstallhwinfo":  {
                             "category":  "Utilities",
                             "content":  "HWiNFO",
                             "description":  "HWiNFO provides comprehensive hardware information and diagnostics for Windows.",
                             "link":  "https://www.hwinfo.com/",
                             "winget":  "REALiX.HWiNFO"
                         },
    "WPFInstallhwmonitor":  {
                                "category":  "Utilities",
                                "content":  "HWMonitor",
                                "description":  "HWMonitor is a hardware monitoring program that reads PC systems main health sensors.",
                                "link":  "https://www.cpuid.com/softwares/hwmonitor.html",
                                "winget":  "CPUID.HWMonitor"
                            },
    "WPFInstallOpenVPN":  {
                              "category":  "Pro Tools",
                              "content":  "OpenVPN Connect",
                              "description":  "OpenVPN Connect is an open-source VPN client that allows you to connect securely to a VPN server. It provides a secure and encrypted connection for protecting your online privacy.",
                              "link":  "https://openvpn.net/",
                              "winget":  "OpenVPNTechnologies.OpenVPNConnect"
                          },
    "WPFInstallrufus":  {
                            "category":  "Utilities",
                            "content":  "Rufus Imager",
                            "description":  "Rufus is a utility that helps format and create bootable USB drives, such as USB keys or pen drives.",
                            "link":  "https://rufus.ie/",
                            "winget":  "Rufus.Rufus"
                        },
    "WPFInstalltreesize":  {
                               "category":  "Utilities",
                               "content":  "TreeSize Free",
                               "description":  "TreeSize Free is a disk space manager that helps you analyze and visualize the space usage on your drives.",
                               "link":  "https://www.jam-software.com/treesize_free/",
                               "winget":  "JAMSoftware.TreeSize.Free"
                           },
    "WPFInstallwingetui":  {
                               "category":  "Utilities",
                               "content":  "UniGetUI",
                               "description":  "UniGetUI is a GUI for Winget, Chocolatey, and other Windows CLI package managers.",
                               "link":  "https://www.marticliment.com/wingetui/",
                               "winget":  "MartiCliment.UniGetUI"
                           },
    "WPFInstallwinscp":  {
                             "category":  "Pro Tools",
                             "content":  "WinSCP",
                             "description":  "WinSCP is a popular open-source SFTP, FTP, and SCP client for Windows. It allows secure file transfers between a local and a remote computer.",
                             "link":  "https://winscp.net/",
                             "winget":  "WinSCP.WinSCP"
                         },
    "WPFInstallwireguard":  {
                                "category":  "Pro Tools",
                                "content":  "WireGuard",
                                "description":  "WireGuard is a fast and modern VPN (Virtual Private Network) protocol. It aims to be simpler and more efficient than other VPN protocols, providing secure and reliable connections.",
                                "link":  "https://www.wireguard.com/",
                                "winget":  "WireGuard.WireGuard"
                            },
    "WPFInstallroyalts":  {
                              "category":  "Pro Tools",
                              "content":  "Royal TS V7",
                              "description":  "Royal TS is a powerful remote connection manager for system administrators and IT professionals.",
                              "link":  "https://www.royalapps.com/ts/",
                              "winget":  "RoyalApps.RoyalTS.7"
                          }
}
'@

$inputXML = @'
<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Windows Deployment and Configuration Assistant"
        Height="800"
        Width="1200"
        MinHeight="700"
        MinWidth="1000"
        WindowStartupLocation="CenterScreen"
        TextOptions.TextFormattingMode="Display"
        TextOptions.TextRenderingMode="ClearType"
        UseLayoutRounding="True"
        SnapsToDevicePixels="True"
        Background="#FF202020">

        <Window.Resources>
                <!-- Modern Fluent Design System Colors -->
                <SolidColorBrush x:Key="SystemAccentBrush"
                                 Color="#FF0078D4"/>
                <SolidColorBrush x:Key="SystemAccentLightBrush"
                                 Color="#FF429CE3"/>
                <SolidColorBrush x:Key="SystemAccentDarkBrush"
                                 Color="#FF005A9E"/>
                <SolidColorBrush x:Key="CardBackgroundBrush"
                                 Color="#FF2D2D30"/>
                <SolidColorBrush x:Key="LayerBackgroundBrush"
                                 Color="#FF202020"/>
                <SolidColorBrush x:Key="SurfaceBackgroundBrush"
                                 Color="#FF1A1A1A"/>
                <SolidColorBrush x:Key="TextPrimaryBrush"
                                 Color="#FFFFFFFF"/>
                <SolidColorBrush x:Key="TextSecondaryBrush"
                                 Color="#FFE0E0E0"/>
                <SolidColorBrush x:Key="TextTertiaryBrush"
                                 Color="#FFB0B0B0"/>
                <SolidColorBrush x:Key="BorderBrush"
                                 Color="#FF404040"/>
                <SolidColorBrush x:Key="HoverBrush"
                                 Color="#FF3C3C3C"/>

                <!-- Modern Card Style -->
                <Style x:Key="ModernCard"
                       TargetType="Border">
                        <Setter Property="Background"
                                Value="{StaticResource CardBackgroundBrush}"/>
                        <Setter Property="CornerRadius"
                                Value="4"/>
                        <Setter Property="BorderThickness"
                                Value="1"/>
                        <Setter Property="BorderBrush"
                                Value="{StaticResource BorderBrush}"/>
                        <Setter Property="Margin"
                                Value="0,0,0,8"/>
                        <Setter Property="Padding"
                                Value="12"/>
                        <Setter Property="Effect">
                                <Setter.Value>
                                        <DropShadowEffect Color="Black"
                                                          BlurRadius="2"
                                                          ShadowDepth="1"
                                                          Opacity="0.15"
                                                          Direction="270"/>
                                </Setter.Value>
                        </Setter>
                </Style>

                <!-- Modern Button Style -->
                <Style x:Key="FluentButton"
                       TargetType="Button">
                        <Setter Property="Background"
                                Value="{StaticResource SystemAccentBrush}"/>
                        <Setter Property="Foreground"
                                Value="{StaticResource TextPrimaryBrush}"/>
                        <Setter Property="BorderThickness"
                                Value="0"/>
                        <Setter Property="Padding"
                                Value="12,8"/>
                        <Setter Property="Margin"
                                Value="4,2"/>
                        <Setter Property="FontSize"
                                Value="13"/>
                        <Setter Property="FontWeight"
                                Value="SemiBold"/>
                        <Setter Property="Cursor"
                                Value="Hand"/>
                        <Setter Property="Height"
                                Value="36"/>
                        <Setter Property="MinWidth"
                                Value="120"/>
                        <Setter Property="Template">
                                <Setter.Value>
                                        <ControlTemplate TargetType="Button">
                                                <Border x:Name="border"
                                                        Background="{TemplateBinding Background}"
                                                        CornerRadius="4"
                                                        BorderThickness="{TemplateBinding BorderThickness}"
                                                        BorderBrush="{TemplateBinding BorderBrush}">
                                                        <ContentPresenter HorizontalAlignment="Center"
                                                                          VerticalAlignment="Center"/>
                                                </Border>
                                                <ControlTemplate.Triggers>
                                                        <Trigger Property="IsMouseOver"
                                                                 Value="True">
                                                                <Setter TargetName="border"
                                                                        Property="Background"
                                                                        Value="{StaticResource SystemAccentLightBrush}"/>
                                                        </Trigger>
                                                </ControlTemplate.Triggers>
                                        </ControlTemplate>
                                </Setter.Value>
                        </Setter>
                </Style>

                <!-- Secondary Button Style -->
                <Style x:Key="FluentButtonSecondary"
                       TargetType="Button"
                       BasedOn="{StaticResource FluentButton}">
                        <Setter Property="Background"
                                Value="Transparent"/>
                        <Setter Property="BorderThickness"
                                Value="1"/>
                        <Setter Property="BorderBrush"
                                Value="{StaticResource BorderBrush}"/>
                </Style>

                <!-- Success Button Style -->
                <Style x:Key="FluentButtonSuccess"
                       TargetType="Button"
                       BasedOn="{StaticResource FluentButton}">
                        <Setter Property="Background"
                                Value="#FF107C10"/>
                </Style>

                <!-- Warning Button Style -->
                <Style x:Key="FluentButtonWarning"
                       TargetType="Button"
                       BasedOn="{StaticResource FluentButton}">
                        <Setter Property="Background"
                                Value="#FFFF8C00"/>
                </Style>

                <!-- Danger Button Style -->
                <Style x:Key="FluentButtonDanger"
                       TargetType="Button"
                       BasedOn="{StaticResource FluentButton}">
                        <Setter Property="Background"
                                Value="#FFD13438"/>
                </Style>

                <!-- Modern Navigation Button Style -->
                <Style x:Key="NavigationButton"
                       TargetType="Button">
                        <Setter Property="Background"
                                Value="Transparent"/>
                        <Setter Property="Foreground"
                                Value="{StaticResource TextSecondaryBrush}"/>
                        <Setter Property="BorderThickness"
                                Value="0"/>
                        <Setter Property="Padding"
                                Value="20,15"/>
                        <Setter Property="FontSize"
                                Value="14"/>
                        <Setter Property="FontWeight"
                                Value="Medium"/>
                        <Setter Property="HorizontalAlignment"
                                Value="Stretch"/>
                        <Setter Property="HorizontalContentAlignment"
                                Value="Left"/>
                        <Setter Property="Cursor"
                                Value="Hand"/>
                        <Setter Property="Template">
                                <Setter.Value>
                                        <ControlTemplate TargetType="Button">
                                                <Border x:Name="border"
                                                        Background="{TemplateBinding Background}"
                                                        CornerRadius="6"
                                                        Margin="8,2">
                                                        <Grid>
                                                                <Rectangle x:Name="indicator"
                                                                           Width="4"
                                                                           HorizontalAlignment="Left"
                                                                           Fill="{StaticResource SystemAccentBrush}"
                                                                           Opacity="0"
                                                                           RadiusX="2"
                                                                           RadiusY="2"/>
                                                                <ContentPresenter Margin="16,0,0,0"
                                                                                  VerticalAlignment="Center"/>
                                                        </Grid>
                                                </Border>
                                                <ControlTemplate.Triggers>
                                                        <Trigger Property="IsMouseOver"
                                                                 Value="True">
                                                                <Setter TargetName="border"
                                                                        Property="Background"
                                                                        Value="{StaticResource HoverBrush}"/>
                                                                <Setter Property="Foreground"
                                                                        Value="{StaticResource TextPrimaryBrush}"/>
                                                        </Trigger>
                                                        <Trigger Property="Tag"
                                                                 Value="Selected">
                                                                <Setter TargetName="border"
                                                                        Property="Background"
                                                                        Value="{StaticResource HoverBrush}"/>
                                                                <Setter TargetName="indicator"
                                                                        Property="Opacity"
                                                                        Value="1"/>
                                                                <Setter Property="Foreground"
                                                                        Value="{StaticResource TextPrimaryBrush}"/>
                                                        </Trigger>
                                                </ControlTemplate.Triggers>
                                        </ControlTemplate>
                                </Setter.Value>
                        </Setter>
                </Style>

                <!-- Modern TextBox Style -->
                <Style x:Key="FluentTextBox"
                       TargetType="TextBox">
                        <Setter Property="Background"
                                Value="{StaticResource CardBackgroundBrush}"/>
                        <Setter Property="Foreground"
                                Value="{StaticResource TextPrimaryBrush}"/>
                        <Setter Property="BorderBrush"
                                Value="{StaticResource BorderBrush}"/>
                        <Setter Property="BorderThickness"
                                Value="1"/>
                        <Setter Property="Padding"
                                Value="8,6"/>
                        <Setter Property="Height"
                                Value="32"/>
                        <Setter Property="FontSize"
                                Value="13"/>
                        <Setter Property="MinWidth"
                                Value="200"/>
                        <Setter Property="Template">
                                <Setter.Value>
                                        <ControlTemplate TargetType="TextBox">
                                                <Border x:Name="border"
                                                        Background="{TemplateBinding Background}"
                                                        BorderBrush="{TemplateBinding BorderBrush}"
                                                        BorderThickness="{TemplateBinding BorderThickness}"
                                                        CornerRadius="4">
                                                        <ScrollViewer x:Name="PART_ContentHost"
                                                                      Focusable="false"
                                                                      HorizontalScrollBarVisibility="Hidden"
                                                                      VerticalScrollBarVisibility="Hidden"
                                                                      Margin="{TemplateBinding Padding}"/>
                                                </Border>
                                                <ControlTemplate.Triggers>
                                                        <Trigger Property="IsMouseOver"
                                                                 Value="True">
                                                                <Setter TargetName="border"
                                                                        Property="BorderBrush"
                                                                        Value="{StaticResource SystemAccentBrush}"/>
                                                        </Trigger>
                                                        <Trigger Property="IsFocused"
                                                                 Value="True">
                                                                <Setter TargetName="border"
                                                                        Property="BorderBrush"
                                                                        Value="{StaticResource SystemAccentBrush}"/>
                                                                <Setter TargetName="border"
                                                                        Property="BorderThickness"
                                                                        Value="2"/>
                                                        </Trigger>
                                                </ControlTemplate.Triggers>
                                        </ControlTemplate>
                                </Setter.Value>
                        </Setter>
                </Style>

                <!-- Modern ComboBox Style -->
                <Style x:Key="FluentComboBox"
                       TargetType="ComboBox">
                        <Setter Property="Background"
                                Value="{StaticResource CardBackgroundBrush}"/>
                        <Setter Property="Foreground"
                                Value="{StaticResource TextPrimaryBrush}"/>
                        <Setter Property="BorderBrush"
                                Value="{StaticResource BorderBrush}"/>
                        <Setter Property="BorderThickness"
                                Value="1"/>
                        <Setter Property="Padding"
                                Value="8,6"/>
                        <Setter Property="Height"
                                Value="32"/>
                        <Setter Property="FontSize"
                                Value="13"/>
                        <Setter Property="MinWidth"
                                Value="200"/>
                </Style>

                <!-- Modern CheckBox Style -->
                <Style x:Key="FluentCheckBox"
                       TargetType="CheckBox">
                        <Setter Property="Foreground"
                                Value="{StaticResource TextPrimaryBrush}"/>
                        <Setter Property="FontSize"
                                Value="13"/>
                        <Setter Property="Margin"
                                Value="0,4"/>
                        <Setter Property="Template">
                                <Setter.Value>
                                        <ControlTemplate TargetType="CheckBox">
                                                <Grid>
                                                        <Grid.ColumnDefinitions>
                                                                <ColumnDefinition Width="Auto"/>
                                                                <ColumnDefinition Width="*"/>
                                                        </Grid.ColumnDefinitions>
                                                        <Border x:Name="checkBorder"
                                                                Grid.Column="0"
                                                                Width="16"
                                                                Height="16"
                                                                Background="{StaticResource CardBackgroundBrush}"
                                                                BorderBrush="{StaticResource BorderBrush}"
                                                                BorderThickness="1"
                                                                CornerRadius="3"
                                                                Margin="0,0,6,0">
                                                                <Path x:Name="checkMark"
                                                                      Data="M 2 5 L 5 8 L 12 1"
                                                                      Stroke="{StaticResource TextPrimaryBrush}"
                                                                      StrokeThickness="1.5"
                                                                      Opacity="0"/>
                                                        </Border>
                                                        <ContentPresenter Grid.Column="1"
                                                                          VerticalAlignment="Center"
                                                                          Content="{TemplateBinding Content}"/>
                                                </Grid>
                                                <ControlTemplate.Triggers>
                                                        <Trigger Property="IsChecked"
                                                                 Value="True">
                                                                <Setter TargetName="checkBorder"
                                                                        Property="Background"
                                                                        Value="{StaticResource SystemAccentBrush}"/>
                                                                <Setter TargetName="checkBorder"
                                                                        Property="BorderBrush"
                                                                        Value="{StaticResource SystemAccentBrush}"/>
                                                                <Setter TargetName="checkMark"
                                                                        Property="Opacity"
                                                                        Value="1"/>
                                                                <Setter TargetName="checkMark"
                                                                        Property="Stroke"
                                                                        Value="White"/>
                                                        </Trigger>
                                                        <Trigger Property="IsMouseOver"
                                                                 Value="True">
                                                                <Setter TargetName="checkBorder"
                                                                        Property="BorderBrush"
                                                                        Value="{StaticResource SystemAccentBrush}"/>
                                                        </Trigger>
                                                </ControlTemplate.Triggers>
                                        </ControlTemplate>
                                </Setter.Value>
                        </Setter>
                </Style>

                <!-- Progress Bar Style -->
                <Style x:Key="FluentProgressBar"
                       TargetType="ProgressBar">
                        <Setter Property="Background"
                                Value="{StaticResource BorderBrush}"/>
                        <Setter Property="Foreground"
                                Value="{StaticResource SystemAccentBrush}"/>
                        <Setter Property="Height"
                                Value="4"/>
                        <Setter Property="Template">
                                <Setter.Value>
                                        <ControlTemplate TargetType="ProgressBar">
                                                <Grid>
                                                        <Border Background="{TemplateBinding Background}"
                                                                CornerRadius="2"/>
                                                        <Rectangle x:Name="PART_Track"
                                                                   Fill="{TemplateBinding Background}"
                                                                   RadiusX="2"
                                                                   RadiusY="2"/>
                                                        <Grid x:Name="PART_Indicator"
                                                              HorizontalAlignment="Left"
                                                              ClipToBounds="True">
                                                                <Rectangle x:Name="Indicator"
                                                                           Fill="{TemplateBinding Foreground}"
                                                                           RadiusX="2"
                                                                           RadiusY="2"/>
                                                        </Grid>
                                                </Grid>
                                        </ControlTemplate>
                                </Setter.Value>
                        </Setter>
                </Style>

                <!-- Header Text Style -->
                <Style x:Key="HeaderText"
                       TargetType="TextBlock">
                        <Setter Property="Foreground"
                                Value="{StaticResource TextPrimaryBrush}"/>
                        <Setter Property="FontSize"
                                Value="24"/>
                        <Setter Property="FontWeight"
                                Value="SemiBold"/>
                        <Setter Property="Margin"
                                Value="0,0,0,8"/>
                </Style>

                <!-- Subtitle Text Style -->
                <Style x:Key="SubtitleText"
                       TargetType="TextBlock">
                        <Setter Property="Foreground"
                                Value="{StaticResource TextSecondaryBrush}"/>
                        <Setter Property="FontSize"
                                Value="14"/>
                        <Setter Property="Margin"
                                Value="0,0,0,16"/>
                </Style>

                <!-- Section Header Style -->
                <Style x:Key="SectionHeader"
                       TargetType="TextBlock">
                        <Setter Property="Foreground"
                                Value="{StaticResource TextPrimaryBrush}"/>
                        <Setter Property="FontSize"
                                Value="14"/>
                        <Setter Property="FontWeight"
                                Value="SemiBold"/>
                        <Setter Property="Margin"
                                Value="0,0,0,6"/>
                </Style>

                <!-- Label Style -->
                <Style x:Key="FluentLabel"
                       TargetType="Label">
                        <Setter Property="Foreground"
                                Value="{StaticResource TextPrimaryBrush}"/>
                        <Setter Property="FontSize"
                                Value="14"/>
                        <Setter Property="Margin"
                                Value="0,0,0,4"/>
                </Style>
        </Window.Resources>

        <Grid>
                <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="*"/>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>

                <!-- App Header -->
                <Border Grid.Row="0"
                        Background="{StaticResource SurfaceBackgroundBrush}"
                        Padding="20,15">
                        <Grid>
                                <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="Auto"/>
                                        <ColumnDefinition Width="*"/>
                                </Grid.ColumnDefinitions>

                                <!-- App Icon and Title -->
                                <StackPanel Grid.Column="0"
                                            Orientation="Horizontal"
                                            VerticalAlignment="Center">
                                        <!-- Icon placeholder -->
                                        <Border Width="32"
                                                Height="32"
                                                Background="{StaticResource SystemAccentBrush}"
                                                CornerRadius="6"
                                                Margin="0,0,12,0">
                                                <TextBlock Text="W"
                                                           FontSize="18"
                                                           FontWeight="Bold"
                                                           Foreground="White"
                                                           HorizontalAlignment="Center"
                                                           VerticalAlignment="Center"/>
                                        </Border>
                                        <StackPanel>
                                                <TextBlock Text="Windows Deployment and Configuration Assistant"
                                                           FontSize="16"
                                                           FontWeight="SemiBold"
                                                           Foreground="{StaticResource TextPrimaryBrush}"/>
                                                <TextBlock Text="Streamline your Windows deployments and configurations"
                                                           FontSize="12"
                                                           Foreground="{StaticResource TextSecondaryBrush}"/>
                                        </StackPanel>
                                </StackPanel>
                        </Grid>
                </Border>

                <!-- Main Content Area -->
                <Grid Grid.Row="1">
                        <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="280"/>
                                <ColumnDefinition Width="*"/>
                        </Grid.ColumnDefinitions>

                        <!-- Navigation Sidebar -->
                        <Border Grid.Column="0"
                                Background="{StaticResource SurfaceBackgroundBrush}"
                                BorderBrush="{StaticResource BorderBrush}"
                                BorderThickness="0,0,1,0">
                                <StackPanel Margin="16,24">
                                        <TextBlock Text="Navigation"
                                                   Style="{StaticResource SectionHeader}"
                                                   Margin="8,0,0,16"/>

                                        <Button Name="NavApplications"
                                                Content="Applications"
                                                Style="{StaticResource NavigationButton}"
                                                Tag="Selected"/>
                                        <Button Name="NavSystemSetup"
                                                Content="System Setup"
                                                Style="{StaticResource NavigationButton}"/>
                                        <Button Name="NavTroubleshooting"
                                                Content="Troubleshooting"
                                                Style="{StaticResource NavigationButton}"/>
                                        <Button Name="NavUpdates"
                                                Content="Updates"
                                                Style="{StaticResource NavigationButton}"/>
                                        <Button Name="NavCloning"
                                                Content="Cloning"
                                                Style="{StaticResource NavigationButton}"/>

                                        <Separator Margin="8,20"
                                                   Background="{StaticResource BorderBrush}"/>

                                        <Button Name="NavAbout"
                                                Content="About"
                                                Style="{StaticResource NavigationButton}"/>
                                </StackPanel>
                        </Border>

                        <!-- Content Area -->
                        <Grid Grid.Column="1"
                              Name="ContentArea"
                              Background="{StaticResource LayerBackgroundBrush}">

                                <!-- Applications Content -->
                                <Grid Name="ApplicationsContent"
                                      Visibility="Visible">
                                        <ScrollViewer VerticalScrollBarVisibility="Auto"
                                                      Margin="20">
                                                <StackPanel>
                                                        <TextBlock Text="Application Management"
                                                                   Style="{StaticResource HeaderText}"/>
                                                        <TextBlock Text="Install and manage applications using WinGet package manager"
                                                                   Style="{StaticResource SubtitleText}"/>

                                                        <!-- Quick Actions -->
                                                        <Border Style="{StaticResource ModernCard}">
                                                                <StackPanel>
                                                                        <TextBlock Text="Quick Actions"
                                                                                   Style="{StaticResource SectionHeader}"/>
                                                                        <StackPanel Orientation="Horizontal"
                                                                                    Margin="0,4,0,0">
                                                                                <Button Name="WPFSelectAllApps"
                                                                                        Content="Select All"
                                                                                        Style="{StaticResource FluentButtonSecondary}"/>
                                                                                <Button Name="WPFDeselectAllApps"
                                                                                        Content="Deselect All"
                                                                                        Style="{StaticResource FluentButtonSecondary}"/>
                                                                                <Button Name="WPFInstallSelectedApps"
                                                                                        Content="Install Selected"
                                                                                        Style="{StaticResource FluentButtonSuccess}"/>
                                                                        </StackPanel>
                                                                </StackPanel>
                                                        </Border>

                                                        <!-- Application Categories -->
                                                        <Border Style="{StaticResource ModernCard}">
                                                                <StackPanel>
                                                                        <TextBlock Text="Available Applications"
                                                                                   Style="{StaticResource SectionHeader}"/>
                                                                        <ScrollViewer Name="ApplicationsScrollViewer"
                                                                                      Height="350"
                                                                                      VerticalScrollBarVisibility="Auto">
                                                                                <StackPanel Name="WPFApplicationsPanel"/>
                                                                        </ScrollViewer>
                                                                </StackPanel>
                                                        </Border>
                                                </StackPanel>
                                        </ScrollViewer>
                                </Grid>

                                <!-- System Setup Content -->
                                <Grid Name="SystemSetupContent"
                                      Visibility="Collapsed">
                                        <ScrollViewer VerticalScrollBarVisibility="Auto"
                                                      Margin="20">
                                                <StackPanel>
                                                        <TextBlock Text="System Configuration"
                                                                   Style="{StaticResource HeaderText}"/>
                                                        <TextBlock Text="Configure network settings, remote access, and server roles"
                                                                   Style="{StaticResource SubtitleText}"/>

                                                        <!-- Network Configuration -->
                                                        <Border Style="{StaticResource ModernCard}">
                                                                <StackPanel>
                                                                        <TextBlock Text="Network Configuration"
                                                                                   Style="{StaticResource SectionHeader}"/>
                                                                        <Grid Margin="0,4,0,0">
                                                                                <Grid.ColumnDefinitions>
                                                                                        <ColumnDefinition Width="*"/>
                                                                                        <ColumnDefinition Width="*"/>
                                                                                </Grid.ColumnDefinitions>
                                                                                <Grid.RowDefinitions>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                </Grid.RowDefinitions>

                                                                                <!-- Network Configuration Mode -->
                                                                                <Label Grid.Row="0"
                                                                                       Grid.ColumnSpan="2"
                                                                                       Content="Network Configuration Mode"
                                                                                       Style="{StaticResource FluentLabel}"
                                                                                       Margin="0,0,0,4"/>
                                                                                <StackPanel Grid.Row="1"
                                                                                            Grid.ColumnSpan="2"
                                                                                            Orientation="Horizontal"
                                                                                            Margin="0,0,0,16">
                                                                                        <RadioButton Name="WPFStaticIP"
                                                                                                     Content="Static IP"
                                                                                                     IsChecked="True"
                                                                                                     Margin="0,0,24,0"
                                                                                                     FontSize="14"
                                                                                                     Foreground="White"/>
                                                                                        <RadioButton Name="WPFDHCP"
                                                                                                     Content="DHCP"
                                                                                                     Margin="0,0,0,0"
                                                                                                     FontSize="14"
                                                                                                     Foreground="White"/>
                                                                                </StackPanel>

                                                                                <!-- IP Address -->
                                                                                <Label Grid.Row="2"
                                                                                       Grid.Column="0"
                                                                                       Content="IP Address"
                                                                                       Style="{StaticResource FluentLabel}"
                                                                                       Margin="0,0,8,4"/>
                                                                                <TextBox Grid.Row="3"
                                                                                         Grid.Column="0"
                                                                                         Name="WPFNetworkIP"
                                                                                         Margin="0,0,8,12"
                                                                                         FontSize="14"
                                                                                         Foreground="#000000"
                                                                                         Background="#FFFFFF"
                                                                                         BorderBrush="#CCCCCC"
                                                                                         BorderThickness="2"
                                                                                         Padding="8,6"
                                                                                         MinHeight="32"
                                                                                         CaretBrush="Black"
                                                                                         SelectionBrush="LightBlue"/>

                                                                                <!-- Subnet Mask -->
                                                                                <Label Grid.Row="2"
                                                                                       Grid.Column="1"
                                                                                       Content="Subnet Mask"
                                                                                       Style="{StaticResource FluentLabel}"
                                                                                       Margin="8,0,0,4"/>
                                                                                <TextBox Grid.Row="3"
                                                                                         Grid.Column="1"
                                                                                         Name="WPFNetworkSubnet"
                                                                                         Margin="8,0,0,12"
                                                                                         FontSize="14"
                                                                                         Foreground="#000000"
                                                                                         Background="#FFFFFF"
                                                                                         BorderBrush="#CCCCCC"
                                                                                         BorderThickness="2"
                                                                                         Padding="8,6"
                                                                                         MinHeight="32"
                                                                                         CaretBrush="Black"
                                                                                         SelectionBrush="LightBlue"/>

                                                                                <!-- Gateway -->
                                                                                <Label Grid.Row="4"
                                                                                       Grid.Column="0"
                                                                                       Content="Gateway"
                                                                                       Style="{StaticResource FluentLabel}"
                                                                                       Margin="0,0,8,4"/>
                                                                                <TextBox Grid.Row="5"
                                                                                         Grid.Column="0"
                                                                                         Name="WPFNetworkGateway"
                                                                                         Margin="0,0,8,12"
                                                                                         FontSize="14"
                                                                                         Foreground="#000000"
                                                                                         Background="#FFFFFF"
                                                                                         BorderBrush="#CCCCCC"
                                                                                         BorderThickness="2"
                                                                                         Padding="8,6"
                                                                                         MinHeight="32"
                                                                                         CaretBrush="Black"
                                                                                         SelectionBrush="LightBlue"/>

                                                                                <!-- DNS Server -->
                                                                                <Label Grid.Row="4"
                                                                                       Grid.Column="1"
                                                                                       Content="DNS Server"
                                                                                       Style="{StaticResource FluentLabel}"
                                                                                       Margin="8,0,0,4"/>
                                                                                <TextBox Grid.Row="5"
                                                                                         Grid.Column="1"
                                                                                         Name="WPFNetworkDNS"
                                                                                         Margin="8,0,0,12"
                                                                                         FontSize="14"
                                                                                         Foreground="#000000"
                                                                                         Background="#FFFFFF"
                                                                                         BorderBrush="#CCCCCC"
                                                                                         BorderThickness="2"
                                                                                         Padding="8,6"
                                                                                         MinHeight="32"
                                                                                         CaretBrush="Black"
                                                                                         SelectionBrush="LightBlue"/>

                                                                                <!-- Alternative DNS Server -->
                                                                                <Label Grid.Row="6"
                                                                                       Grid.Column="0"
                                                                                       Content="Alternative DNS"
                                                                                       Style="{StaticResource FluentLabel}"
                                                                                       Margin="0,0,8,4"/>
                                                                                <TextBox Grid.Row="7"
                                                                                         Grid.Column="0"
                                                                                         Name="WPFNetworkDNSAlt"
                                                                                         Margin="0,0,8,12"
                                                                                         FontSize="14"
                                                                                         Foreground="#000000"
                                                                                         Background="#FFFFFF"
                                                                                         BorderBrush="#CCCCCC"
                                                                                         BorderThickness="2"
                                                                                         Padding="8,6"
                                                                                         MinHeight="32"
                                                                                         CaretBrush="Black"
                                                                                         SelectionBrush="LightBlue"/>

                                                                                <!-- IPv6 Option -->
                                                                                <CheckBox Grid.Row="7"
                                                                                          Grid.Column="1"
                                                                                          Name="WPFDisableIPv6"
                                                                                          Content="Disable IPv6"
                                                                                          VerticalAlignment="Center"
                                                                                          Margin="8,0,0,12"
                                                                                          FontSize="14"
                                                                                          Foreground="White"/>

                                                                                <!-- Apply Button -->
                                                                                <Button Grid.Row="8"
                                                                                        Grid.ColumnSpan="2"
                                                                                        Name="WPFConfigureNetwork"
                                                                                        Content="Apply Network Configuration"
                                                                                        Style="{StaticResource FluentButton}"
                                                                                        HorizontalAlignment="Left"
                                                                                        Margin="0,4,0,0"/>
                                                                        </Grid>
                                                                </StackPanel>
                                                        </Border>

                                                        <!-- Remote Access -->
                                                        <Border Style="{StaticResource ModernCard}">
                                                                <StackPanel>
                                                                        <TextBlock Text="Remote Access"
                                                                                   Style="{StaticResource SectionHeader}"/>
                                                                        <CheckBox Name="WPFRDPNetworkAuth"
                                                                                  Content="Require Network Level Authentication"
                                                                                  Style="{StaticResource FluentCheckBox}"
                                                                                  IsChecked="True"
                                                                                  Margin="0,4,0,8"/>
                                                                        <Button Name="WPFEnableRDP"
                                                                                Content="Enable Remote Desktop"
                                                                                Style="{StaticResource FluentButton}"
                                                                                HorizontalAlignment="Left"/>
                                                                </StackPanel>
                                                        </Border>
                                                </StackPanel>
                                        </ScrollViewer>
                                </Grid>

                                <!-- Troubleshooting Content -->
                                <Grid Name="TroubleshootingContent"
                                      Visibility="Collapsed">
                                        <ScrollViewer VerticalScrollBarVisibility="Auto"
                                                      Margin="24">
                                                <StackPanel>
                                                        <TextBlock Text="System Diagnostics"
                                                                   Style="{StaticResource HeaderText}"/>
                                                        <TextBlock Text="Run system diagnostics and troubleshooting tools"
                                                                   Style="{StaticResource SubtitleText}"/>

                                                        <!-- System Diagnostics -->
                                                        <Border Style="{StaticResource ModernCard}">
                                                                <StackPanel>
                                                                        <TextBlock Text="System Health Checks"
                                                                                   Style="{StaticResource SectionHeader}"/>
                                                                        <WrapPanel>
                                                                                <Button Name="WPFRunDISM"
                                                                                        Content="Run DISM Scan"
                                                                                        Style="{StaticResource FluentButton}"/>
                                                                                <Button Name="WPFRunSFC"
                                                                                        Content="Run SFC Scan"
                                                                                        Style="{StaticResource FluentButton}"/>
                                                                                <Button Name="WPFRunCHKDSK"
                                                                                        Content="Run CHKDSK"
                                                                                        Style="{StaticResource FluentButton}"/>
                                                                                <Button Name="WPFRunDiagnostics"
                                                                                        Content="Run All Diagnostics"
                                                                                        Style="{StaticResource FluentButtonWarning}"/>
                                                                        </WrapPanel>
                                                                </StackPanel>
                                                        </Border>
                                                </StackPanel>
                                        </ScrollViewer>
                                </Grid>

                                <!-- Updates Content - Angepasste Version -->
                                <Grid Name="UpdatesContent"
                                      Visibility="Collapsed">
                                        <ScrollViewer VerticalScrollBarVisibility="Auto"
                                                      Margin="24">
                                                <StackPanel>
                                                        <TextBlock Text="Update Management"
                                                                   Style="{StaticResource HeaderText}"/>
                                                        <TextBlock Text="Manage Windows Updates and application updates"
                                                                   Style="{StaticResource SubtitleText}"/>

                                                        <!-- Application Updates -->
                                                        <Border Style="{StaticResource ModernCard}">
                                                                <StackPanel>
                                                                        <TextBlock Text="Application Updates"
                                                                                   Style="{StaticResource SectionHeader}"/>
                                                                        <WrapPanel>
                                                                                <Button Name="WPFListAppUpdate"
                                                                                        Content="List All Updates"
                                                                                        Style="{StaticResource FluentButton}"/>
                                                                                <Button Name="WPFUpdateApps"
                                                                                        Content="Update All Apps"
                                                                                        Style="{StaticResource FluentButton}"/>
                                                                        </WrapPanel>
                                                                </StackPanel>
                                                        </Border>
                                                        <!-- Domain Controller Upgrade Preparation -->
                                                        <Border Style="{StaticResource ModernCard}">
                                                                <StackPanel>
                                                                        <TextBlock Text="Domain Controller Upgrade Preparation UNTESTED"
                                                                                   Style="{StaticResource SectionHeader}"
                                                                                   Foreground="#FF0000"/>
                                                                        <TextBlock Text="Specialized preparation for Active Directory Domain Controllers including Forest/Domain Prep"
                                                                                   Foreground="{StaticResource TextSecondaryBrush}"
                                                                                   Margin="0,0,0,12"/>

                                                                        <Grid>
                                                                                <Grid.ColumnDefinitions>
                                                                                        <ColumnDefinition Width="*"/>
                                                                                        <ColumnDefinition Width="*"/>
                                                                                </Grid.ColumnDefinitions>
                                                                                <Grid.RowDefinitions>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                </Grid.RowDefinitions>

                                                                                <!-- Target Windows Version -->
                                                                                <Label Grid.Row="0"
                                                                                       Grid.Column="0"
                                                                                       Content="Target Windows Server Version"
                                                                                       Style="{StaticResource FluentLabel}"/>
                                                                                <ComboBox Grid.Row="1"
                                                                                          Grid.Column="0"
                                                                                          Name="WPFDCTargetVersion"
                                                                                          Style="{StaticResource FluentComboBox}"
                                                                                          Margin="0,0,8,12"
                                                                                          Background="#FFFFFF"
                                                                                          Foreground="#000000"
                                                                                          BorderBrush="#CCCCCC">
                                                                                        <ComboBoxItem Content="Windows Server 2019"
                                                                                                      Background="#FFFFFF"
                                                                                                      Foreground="#000000"/>
                                                                                        <ComboBoxItem Content="Windows Server 2022"
                                                                                                      IsSelected="True"
                                                                                                      Background="#FFFFFF"
                                                                                                      Foreground="#000000"/>
                                                                                        <ComboBoxItem Content="Windows Server 2025"
                                                                                                      Background="#FFFFFF"
                                                                                                      Foreground="#000000"/>
                                                                                </ComboBox>

                                                                                <!-- ADPREP Options -->
                                                                                <Label Grid.Row="0"
                                                                                       Grid.Column="1"
                                                                                       Content="ADPREP Operations"
                                                                                       Style="{StaticResource FluentLabel}"/>
                                                                                <StackPanel Grid.Row="1"
                                                                                            Grid.Column="1"
                                                                                            Margin="8,0,0,12">
                                                                                        <CheckBox Name="WPFDCForestPrep"
                                                                                                  Content="Include Forest Prep Analysis"
                                                                                                  Style="{StaticResource FluentCheckBox}"
                                                                                                  IsChecked="True"
                                                                                                  Margin="0,0,0,4"/>
                                                                                        <CheckBox Name="WPFDCDomainPrep"
                                                                                                  Content="Include Domain Prep Analysis"
                                                                                                  Style="{StaticResource FluentCheckBox}"
                                                                                                  IsChecked="True"
                                                                                                  Margin="0,0,0,4"/>
                                                                                </StackPanel>

                                                                                <!-- Action Buttons -->
                                                                                <StackPanel Grid.Row="2"
                                                                                            Grid.ColumnSpan="2"
                                                                                            Orientation="Horizontal"
                                                                                            Margin="0,8,0,0">
                                                                                        <Button Name="WPFPrepareDC"
                                                                                                Content="Prepare Domain Controller"
                                                                                                Style="{StaticResource FluentButtonWarning}"
                                                                                                Margin="0,0,8,0"/>
                                                                                        <Button Name="WPFAnalyzeFSMO"
                                                                                                Content="Analyze FSMO Roles"
                                                                                                Style="{StaticResource FluentButtonSecondary}"
                                                                                                Margin="0,0,8,0"/>
                                                                                        <Button Name="WPFCheckReplication"
                                                                                                Content="Check AD Replication"
                                                                                                Style="{StaticResource FluentButtonSecondary}"/>
                                                                                </StackPanel>
                                                                        </Grid>

                                                                        <!-- Warning Box -->
                                                                        <Border Background="#FFF3CD"
                                                                                BorderBrush="#FFEAA52B"
                                                                                BorderThickness="1"
                                                                                CornerRadius="4"
                                                                                Padding="12"
                                                                                Margin="0,16,0,0">
                                                                                <StackPanel>
                                                                                        <TextBlock Text="âš ï¸ Domain Controller Upgrade Warning"
                                                                                                   FontWeight="Bold"
                                                                                                   Foreground="#856404"
                                                                                                   Margin="0,0,0,4"/>
                                                                                        <TextBlock Text="Domain Controller upgrades affect the entire Active Directory environment. Ensure proper planning, backups, and testing before proceeding."
                                                                                                   TextWrapping="Wrap"
                                                                                                   Foreground="#856404"
                                                                                                   FontSize="12"/>
                                                                                </StackPanel>
                                                                        </Border>
                                                                </StackPanel>
                                                        </Border>

                                                        <!-- Reboot Management -->
                                                        <Border Style="{StaticResource ModernCard}">
                                                                <StackPanel>
                                                                        <TextBlock Text="Reboot Management"
                                                                                   Style="{StaticResource SectionHeader}"/>
                                                                        <TextBlock Text="Manage system restarts and pending reboot status"
                                                                                   Foreground="{StaticResource TextSecondaryBrush}"
                                                                                   Margin="0,0,0,12"/>
                                                                        <WrapPanel>
                                                                                <Button Name="WPFCheckPendingReboot"
                                                                                        Content="Check Pending Reboot"
                                                                                        Style="{StaticResource FluentButtonSecondary}"/>
                                                                                <Button Name="WPFScheduleReboot"
                                                                                        Content="Schedule Restart"
                                                                                        Style="{StaticResource FluentButtonWarning}"/>
                                                                                <Button Name="WPFCancelReboot"
                                                                                        Content="Cancel Scheduled Restart"
                                                                                        Style="{StaticResource FluentButtonSecondary}"/>
                                                                        </WrapPanel>
                                                                </StackPanel>
                                                        </Border>
                                                </StackPanel>
                                        </ScrollViewer>
                                </Grid>

                                <!-- Cloning Content -->
                                <Grid Name="CloningContent"
                                      Visibility="Collapsed">
                                        <ScrollViewer VerticalScrollBarVisibility="Auto"
                                                      Margin="24">
                                                <StackPanel>
                                                        <TextBlock Text="System Cloning and Imaging"
                                                                   Style="{StaticResource HeaderText}"/>
                                                        <TextBlock Text="Prepare systems for cloning and create deployment images"
                                                                   Style="{StaticResource SubtitleText}"/>

                                                        <!-- Sysprep Configuration -->
                                                        <Border Style="{StaticResource ModernCard}">
                                                                <StackPanel>
                                                                        <TextBlock Text="Sysprep Configuration"
                                                                                   Style="{StaticResource SectionHeader}"/>
                                                                        <TextBlock Text="Configure system preparation options before running Sysprep"
                                                                                   Foreground="{StaticResource TextSecondaryBrush}"
                                                                                   Margin="0,0,0,16"/>

                                                                        <StackPanel Orientation="Horizontal"
                                                                                    Margin="0,0,0,20">
                                                                                <CheckBox Name="WPFSysprepGeneralize"
                                                                                          Content="Generalize System"
                                                                                          Style="{StaticResource FluentCheckBox}"
                                                                                          IsChecked="True"
                                                                                          Margin="0,0,24,0"/>
                                                                                <CheckBox Name="WPFSysprepOOBE"
                                                                                          Content="Enter OOBE Mode"
                                                                                          Style="{StaticResource FluentCheckBox}"
                                                                                          IsChecked="True"
                                                                                          Margin="0,0,24,0"/>
                                                                                <CheckBox Name="WPFSysprepShutdown"
                                                                                          Content="Shutdown After Sysprep"
                                                                                          Style="{StaticResource FluentCheckBox}"
                                                                                          IsChecked="True"/>
                                                                        </StackPanel>

                                                                        <WrapPanel>
                                                                                <Button Name="WPFPrepareSysprep"
                                                                                        Content="Prepare System"
                                                                                        Style="{StaticResource FluentButton}"/>
                                                                                <Button Name="WPFRunSysprep"
                                                                                        Content="Run Sysprep"
                                                                                        Style="{StaticResource FluentButtonDanger}"/>
                                                                        </WrapPanel>
                                                                </StackPanel>
                                                        </Border>

                                                        <!-- Cleanup Options -->
                                                        <Border Style="{StaticResource ModernCard}">
                                                                <StackPanel>
                                                                        <TextBlock Text="Pre-Clone Cleanup"
                                                                                   Style="{StaticResource SectionHeader}"/>
                                                                        <TextBlock Text="Clean temporary files and optimize system for imaging"
                                                                                   Foreground="{StaticResource TextSecondaryBrush}"
                                                                                   Margin="0,0,0,16"/>

                                                                        <StackPanel Orientation="Horizontal"
                                                                                    Margin="0,0,0,20">
                                                                                <CheckBox Name="WPFCleanupTemp"
                                                                                          Content="Clear Temp Files"
                                                                                          Style="{StaticResource FluentCheckBox}"
                                                                                          IsChecked="True"
                                                                                          Margin="0,0,24,0"/>
                                                                                <CheckBox Name="WPFCleanupLogs"
                                                                                          Content="Clear Event Logs"
                                                                                          Style="{StaticResource FluentCheckBox}"
                                                                                          IsChecked="True"
                                                                                          Margin="0,0,24,0"/>
                                                                                <CheckBox Name="WPFCleanupRecycle"
                                                                                          Content="Empty Recycle Bin"
                                                                                          Style="{StaticResource FluentCheckBox}"
                                                                                          IsChecked="True"/>
                                                                        </StackPanel>

                                                                        <Button Name="WPFRunCleanup"
                                                                                Content="Run System Cleanup"
                                                                                Style="{StaticResource FluentButtonSuccess}"
                                                                                HorizontalAlignment="Left"/>
                                                                </StackPanel>
                                                        </Border>
                                                </StackPanel>
                                        </ScrollViewer>
                                </Grid>

                                <!-- About Content -->
                                <Grid Name="AboutContent"
                                      Visibility="Collapsed">
                                        <ScrollViewer VerticalScrollBarVisibility="Auto"
                                                      Margin="24">
                                                <StackPanel>
                                                        <TextBlock Text="About WDCA"
                                                                   Style="{StaticResource HeaderText}"/>

                                                        <!-- Application Info -->
                                                        <Border Style="{StaticResource ModernCard}">
                                                                <StackPanel>
                                                                        <Grid>
                                                                                <Grid.ColumnDefinitions>
                                                                                        <ColumnDefinition Width="Auto"/>
                                                                                        <ColumnDefinition Width="*"/>
                                                                                </Grid.ColumnDefinitions>

                                                                                <!-- App Icon -->
                                                                                <Border Grid.Column="0"
                                                                                        Width="64"
                                                                                        Height="64"
                                                                                        Background="{StaticResource SystemAccentBrush}"
                                                                                        CornerRadius="12"
                                                                                        Margin="0,0,20,0">
                                                                                        <TextBlock Text="W"
                                                                                                   FontSize="32"
                                                                                                   FontWeight="Bold"
                                                                                                   Foreground="White"
                                                                                                   HorizontalAlignment="Center"
                                                                                                   VerticalAlignment="Center"/>
                                                                                </Border>

                                                                                <!-- App Details -->
                                                                                <StackPanel Grid.Column="1"
                                                                                            VerticalAlignment="Center">
                                                                                        <TextBlock Text="Windows Deployment and Configuration Assistant"
                                                                                                   FontSize="20"
                                                                                                   FontWeight="SemiBold"
                                                                                                   Foreground="{StaticResource TextPrimaryBrush}"
                                                                                                   Margin="0,0,0,4"/>
                                                                                        <TextBlock Text="Version 25.01.01"
                                                                                                   FontSize="14"
                                                                                                   Foreground="{StaticResource TextSecondaryBrush}"
                                                                                                   Margin="0,0,0,4"/>
                                                                                        <TextBlock Text="Â© 2025 Tobayashi-san. Licensed under MIT License."
                                                                                                   FontSize="12"
                                                                                                   Foreground="{StaticResource TextTertiaryBrush}"/>
                                                                                </StackPanel>
                                                                        </Grid>

                                                                        <Separator Margin="0,20"
                                                                                   Background="{StaticResource BorderBrush}"/>

                                                                        <TextBlock Text="A comprehensive PowerShell-based utility with modern WPF interface for streamlining Windows system deployment, configuration, troubleshooting, and cloning operations."
                                                                                   TextWrapping="Wrap"
                                                                                   Foreground="{StaticResource TextSecondaryBrush}"
                                                                                   Margin="0,0,0,16"/>

                                                                        <StackPanel Orientation="Horizontal">
                                                                                <Button Content="View Documentation"
                                                                                        Style="{StaticResource FluentButton}"/>
                                                                                <Button Content="Report Issue"
                                                                                        Style="{StaticResource FluentButtonSecondary}"/>
                                                                                <Button Content="Check for Updates"
                                                                                        Style="{StaticResource FluentButtonSecondary}"/>
                                                                        </StackPanel>
                                                                </StackPanel>
                                                        </Border>

                                                        <!-- System Info -->
                                                        <Border Style="{StaticResource ModernCard}">
                                                                <StackPanel>
                                                                        <TextBlock Text="System Information"
                                                                                   Style="{StaticResource SectionHeader}"/>

                                                                        <Grid Margin="0,16,0,0">
                                                                                <Grid.ColumnDefinitions>
                                                                                        <ColumnDefinition Width="150"/>
                                                                                        <ColumnDefinition Width="*"/>
                                                                                </Grid.ColumnDefinitions>
                                                                                <Grid.RowDefinitions>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                        <RowDefinition Height="Auto"/>
                                                                                </Grid.RowDefinitions>

                                                                                <TextBlock Grid.Row="0"
                                                                                           Grid.Column="0"
                                                                                           Text="Computer Name:"
                                                                                           Foreground="{StaticResource TextSecondaryBrush}"
                                                                                           Margin="0,0,0,8"/>
                                                                                <TextBlock Grid.Row="0"
                                                                                           Grid.Column="1"
                                                                                           Name="SystemComputerName"
                                                                                           Text="COMPUTER-NAME"
                                                                                           Foreground="{StaticResource TextPrimaryBrush}"
                                                                                           Margin="0,0,0,8"/>

                                                                                <TextBlock Grid.Row="1"
                                                                                           Grid.Column="0"
                                                                                           Text="PowerShell Version:"
                                                                                           Foreground="{StaticResource TextSecondaryBrush}"
                                                                                           Margin="0,0,0,8"/>
                                                                                <TextBlock Grid.Row="1"
                                                                                           Grid.Column="1"
                                                                                           Name="PowerShellVersion"
                                                                                           Text="5.1.22621.2506"
                                                                                           Foreground="{StaticResource TextPrimaryBrush}"
                                                                                           Margin="0,0,0,8"/>

                                                                                <TextBlock Grid.Row="2"
                                                                                           Grid.Column="0"
                                                                                           Text="Admin Rights:"
                                                                                           Foreground="{StaticResource TextSecondaryBrush}"
                                                                                           Margin="0,0,0,8"/>
                                                                                <TextBlock Grid.Row="2"
                                                                                           Grid.Column="1"
                                                                                           Name="AdminStatus"
                                                                                           Text="Yes"
                                                                                           Foreground="#FF107C10"
                                                                                           Margin="0,0,0,8"/>

                                                                                <TextBlock Grid.Row="3"
                                                                                           Grid.Column="0"
                                                                                           Text="WinGet Available:"
                                                                                           Foreground="{StaticResource TextSecondaryBrush}"
                                                                                           Margin="0,0,0,8"/>
                                                                                <TextBlock Grid.Row="3"
                                                                                           Grid.Column="1"
                                                                                           Name="WinGetStatus"
                                                                                           Text="Yes"
                                                                                           Foreground="#FF107C10"
                                                                                           Margin="0,0,0,8"/>

                                                                                <TextBlock Grid.Row="4"
                                                                                           Grid.Column="0"
                                                                                           Text="Log File:"
                                                                                           Foreground="{StaticResource TextSecondaryBrush}"/>
                                                                                <TextBlock Grid.Row="4"
                                                                                           Grid.Column="1"
                                                                                           Name="LogFilePath"
                                                                                           Text="C:\Temp\WDCA_20250101_120000.log"
                                                                                           Foreground="{StaticResource TextSecondaryBrush}"/>
                                                                        </Grid>
                                                                </StackPanel>
                                                        </Border>
                                                </StackPanel>
                                        </ScrollViewer>
                                </Grid>
                        </Grid>
                </Grid>

                <!-- Progress Bar -->
                <ProgressBar Grid.Row="2"
                             Name="WPFProgressBar"
                             Style="{StaticResource FluentProgressBar}"
                             Margin="24,0"/>

                <!-- Status Bar -->
                <Border Grid.Row="3"
                        Background="{StaticResource SurfaceBackgroundBrush}"
                        Height="48">
                        <Grid Margin="24,0">
                                <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="*"/>
                                        <ColumnDefinition Width="Auto"/>
                                </Grid.ColumnDefinitions>

                                <StackPanel Grid.Column="0"
                                            Orientation="Horizontal"
                                            VerticalAlignment="Center">
                                        <Ellipse Width="8"
                                                 Height="8"
                                                 Fill="#FF107C10"
                                                 Margin="0,0,8,0"/>
                                        <TextBlock Name="WPFStatusText"
                                                   Text="Ready - Windows Deployment and Configuration Assistant"
                                                   Foreground="{StaticResource TextSecondaryBrush}"
                                                   VerticalAlignment="Center"/>
                                </StackPanel>

                                <StackPanel Grid.Column="1"
                                            Orientation="Horizontal"
                                            VerticalAlignment="Center">
                                        <TextBlock Text="v"
                                                   Foreground="{StaticResource TextTertiaryBrush}"/>
                                        <TextBlock Name="WPFVersionText"
                                                   Text="25.01.01"
                                                   Foreground="{StaticResource TextTertiaryBrush}"
                                                   Margin="2,0,0,0"/>
                                </StackPanel>
                        </Grid>
                </Border>
        </Grid>
</Window>
'@

# Fixed scripts/main.ps1 with Form-Validation and Error Handling

try {
    Write-Logger "Starting WDCA UI initialization..." "INFO"

    # Check if inputXML exists
    if (-not $inputXML) {
        throw "inputXML variable is not defined or empty"
    }

    # XAML parsing with improved error handling
    try {
        [xml]$XAML = $inputXML
        Write-Logger "XAML parsed successfully" "INFO"

        $reader = (New-Object System.Xml.XmlNodeReader $XAML)
        $global:sync.Form = [Windows.Markup.XamlReader]::Load($reader)

        # Critical Form validation
        if (-not $global:sync.Form) {
            throw "Failed to load XAML - Form is null"
        }

        # Additional Form validation
        if (-not $global:sync.Form.GetType().Name.Contains("Window")) {
            throw "Loaded object is not a Window type"
        }

        Write-Logger "XAML loaded successfully - Form created and validated" "INFO"
    }
    catch [System.Windows.Markup.XamlParseException] {
        Write-Logger "XAML Parse Error: $($_.Exception.Message)" "ERROR"
        Write-Logger "Line: $($_.Exception.LineNumber), Position: $($_.Exception.LinePosition)" "ERROR"
        throw "XAML parsing failed: $($_.Exception.Message)"
    }
    catch {
        Write-Logger "Error loading XAML: $($_.Exception.Message)" "ERROR"
        throw "XAML loading failed: $($_.Exception.Message)"
    }

    # Safely initialize components with error checking
    try {
        Write-Logger "Initializing XAML variables..." "INFO"
        Initialize-WDCAVariables
    }
    catch {
        Write-Logger "Error initializing XAML variables: $($_.Exception.Message)" "ERROR"
    }

    try {
        Write-Logger "Initializing theme manager..." "INFO"
        Initialize-ThemeManager
    }
    catch {
        Write-Logger "Error initializing theme manager: $($_.Exception.Message)" "ERROR"
    }

    try {
        Write-Logger "Applying system theme..." "INFO"
        $systemTheme = Get-SystemThemePreference
        Set-WDCATheme -ThemeName $systemTheme
    }
    catch {
        Write-Logger "Error applying theme: $($_.Exception.Message)" "ERROR"
    }

    try {
        Write-Logger "Initializing window controls..." "INFO"
        Initialize-WindowControls
    }
    catch {
        Write-Logger "Error initializing window controls: $($_.Exception.Message)" "ERROR"
    }

    try {
        Write-Logger "Initializing applications..." "INFO"
        Initialize-WDCAApplications
    }
    catch {
        Write-Logger "Error initializing applications: $($_.Exception.Message)" "ERROR"
    }

    Write-Logger "WDCA UI successfully initialized" "INFO"

    # Initialize navigation
    $currentTab = "Applications"

    function Show-Content {
        param([string]$TabName)

        try {
            # Hide all content panels
            @("ApplicationsContent", "SystemSetupContent", "TroubleshootingContent", "UpdatesContent", "CloningContent", "SettingsContent", "AboutContent") | ForEach-Object {
                if ($sync[$_]) {
                    $sync[$_].Visibility = "Collapsed"
                }
            }

            # Show selected content
            $contentName = "${TabName}Content"
            if ($sync[$contentName]) {
                $sync[$contentName].Visibility = "Visible"
            }

            # Update navigation button states
            @("NavApplications", "NavSystemSetup", "NavTroubleshooting", "NavUpdates", "NavCloning", "NavSettings", "NavAbout") | ForEach-Object {
                if ($sync[$_]) {
                    $sync[$_].Tag = ""
                }
            }

            $navButtonName = "Nav$TabName"
            if ($sync[$navButtonName]) {
                $sync[$navButtonName].Tag = "Selected"
            }

            $script:currentTab = $TabName
            Set-WDCAStatus "Switched to $TabName"
        }
        catch {
            Write-Logger "Error switching to tab ${TabName}: $($_.Exception.Message)" "ERROR"
        }
    }

    # Navigation event handlers with error handling
    if ($sync.NavApplications) {
        $sync.NavApplications.Add_Click({
                try {
                    if ((Get-ActiveAsyncOperations).Count -eq 0) {
                        Show-Content "Applications"
                    }
                    else {
                        [System.Windows.MessageBox]::Show("Please wait for current operation to complete.", "WDCA - Operation in Progress", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Information)
                    }
                }
                catch {
                    Write-Logger "Error in Applications navigation: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    if ($sync.NavSystemSetup) {
        $sync.NavSystemSetup.Add_Click({
                try {
                    if ((Get-ActiveAsyncOperations).Count -eq 0) {
                        Show-Content "SystemSetup"
                    }
                    else {
                        [System.Windows.MessageBox]::Show("Please wait for current operation to complete.", "WDCA - Operation in Progress", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Information)
                    }
                }
                catch {
                    Write-Logger "Error in SystemSetup navigation: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    if ($sync.NavTroubleshooting) {
        $sync.NavTroubleshooting.Add_Click({
                try {
                    if ((Get-ActiveAsyncOperations).Count -eq 0) {
                        Show-Content "Troubleshooting"
                    }
                    else {
                        [System.Windows.MessageBox]::Show("Please wait for current operation to complete.", "WDCA - Operation in Progress", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Information)
                    }
                }
                catch {
                    Write-Logger "Error in Troubleshooting navigation: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    if ($sync.NavUpdates) {
        $sync.NavUpdates.Add_Click({
                try {
                    if ((Get-ActiveAsyncOperations).Count -eq 0) {
                        Show-Content "Updates"
                    }
                    else {
                        [System.Windows.MessageBox]::Show("Please wait for current operation to complete.", "WDCA - Operation in Progress", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Information)
                    }
                }
                catch {
                    Write-Logger "Error in Updates navigation: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    if ($sync.WPFPrepareDC) {
    $sync.WPFPrepareDC.Add_Click({
        try {
            $targetVersion = $sync.WPFDCTargetVersion.SelectedItem.Content
            Invoke-DomainControllerUpgradePrep -TargetWindowsVersion $targetVersion
        } catch {
            Write-Logger "Error in DC Prep: $($_.Exception.Message)" "ERROR"
        }
    })
}

if ($sync.WPFAnalyzeFSMO) {
    $sync.WPFAnalyzeFSMO.Add_Click({
        try {
            Invoke-FSMORoleAnalysis
        } catch {
            Write-Logger "Error in FSMO Analysis: $($_.Exception.Message)" "ERROR"
        }
    })
}

if ($sync.WPFCheckReplication) {
    $sync.WPFCheckReplication.Add_Click({
        try {
            Invoke-ADReplicationCheck
        } catch {
            Write-Logger "Error in Replication Check: $($_.Exception.Message)" "ERROR"
        }
    })
}

    if ($sync.NavCloning) {
        $sync.NavCloning.Add_Click({
                try {
                    if ((Get-ActiveAsyncOperations).Count -eq 0) {
                        Show-Content "Cloning"
                    }
                    else {
                        [System.Windows.MessageBox]::Show("Please wait for current operation to complete.", "WDCA - Operation in Progress", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Information)
                    }
                }
                catch {
                    Write-Logger "Error in Cloning navigation: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    if ($sync.NavSettings) {
        $sync.NavSettings.Add_Click({
                try {
                    Show-Content "Settings"
                }
                catch {
                    Write-Logger "Error in Settings navigation: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    if ($sync.NavAbout) {
        $sync.NavAbout.Add_Click({
                try {
                    Show-Content "About"
                }
                catch {
                    Write-Logger "Error in About navigation: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    # Application event handlers
    if ($sync.WPFInstallSelectedApps) {
        $sync.WPFInstallSelectedApps.Add_Click({
                try {
                    Invoke-WPFApplicationsAsync
                }
                catch {
                    Write-Logger "Error in Install Selected Apps: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    if ($sync.WPFSelectAllApps) {
        $sync.WPFSelectAllApps.Add_Click({
                try {
                    if ($sync.configs.applications) {
                        $sync.configs.applications.PSObject.Properties | ForEach-Object {
                            $checkboxName = $_.Name
                            if ($sync[$checkboxName]) {
                                $sync[$checkboxName].IsChecked = $true
                            }
                        }
                    }
                    Set-WDCAStatus "Selected all applications"
                }
                catch {
                    Write-Logger "Error in Select All Apps: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    if ($sync.WPFDeselectAllApps) {
        $sync.WPFDeselectAllApps.Add_Click({
                try {
                    if ($sync.configs.applications) {
                        $sync.configs.applications.PSObject.Properties | ForEach-Object {
                            $checkboxName = $_.Name
                            if ($sync[$checkboxName]) {
                                $sync[$checkboxName].IsChecked = $false
                            }
                        }
                    }
                    Set-WDCAStatus "Deselected all applications"
                }
                catch {
                    Write-Logger "Error in Deselect All Apps: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    # System Setup event handlers
    if ($sync.WPFConfigureNetwork) {
        $sync.WPFConfigureNetwork.Add_Click({
                try {
                    Invoke-WPFSystemSetup -Action "Network"
                }
                catch {
                    Write-Logger "Error in Configure Network: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    if ($sync.WPFEnableRDP) {
        $sync.WPFEnableRDP.Add_Click({
                try {
                    Invoke-WPFSystemSetup -Action "RDP"
                }
                catch {
                    Write-Logger "Error in Enable RDP: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    # Troubleshooting event handlers
    if ($sync.WPFRunDiagnostics) {
        $sync.WPFRunDiagnostics.Add_Click({
                try {
                    Invoke-SystemDiagnosticsAsync
                }
                catch {
                    Write-Logger "Error in Run Diagnostics: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    if ($sync.WPFRunDISM) {
        $sync.WPFRunDISM.Add_Click({
                try {
                    Invoke-WPFTroubleshooting -Action "DISM"
                }
                catch {
                    Write-Logger "Error in Run DISM: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    if ($sync.WPFRunSFC) {
        $sync.WPFRunSFC.Add_Click({
                try {
                    Invoke-WPFTroubleshooting -Action "SFC"
                }
                catch {
                    Write-Logger "Error in Run SFC: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    if ($sync.WPFRunCHKDSK) {
        $sync.WPFRunCHKDSK.Add_Click({
                try {
                    Invoke-WPFTroubleshooting -Action "CHKDSK"
                }
                catch {
                    Write-Logger "Error in Run CHKDSK: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    if ($sync.WPFListAppUpdate) {
        $sync.WPFListAppUpdate.Add_Click({
                try {
                    Invoke-WPFListAppUpdates
                }
                catch {
                    Write-Logger "Error in Update Apps: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    if ($sync.WPFUpdateApps) {
        $sync.WPFUpdateApps.Add_Click({
                try {
                    Invoke-WPFUpdateApps
                }
                catch {
                    Write-Logger "Error in Upgrade Apps: $($_.Exception.Message)" "ERROR"
                }
            })
    }

    # Update status and version display
    if ($sync.WPFVersionText) {
        $sync.WPFVersionText.Text = "25.01.01"
    }

    if ($sync.PowerShellVersion) {
        $sync.PowerShellVersion.Text = $PSVersionTable.PSVersion.ToString()
    }

    if ($sync.AdminStatus) {
        $isAdmin = Test-IsAdmin
        $sync.AdminStatus.Text = if ($isAdmin) { "Yes" } else { "No" }
        $sync.AdminStatus.Foreground = if ($isAdmin) { "#FF107C10" } else { "#FFD13438" }
    }

    if ($sync.WinGetStatus) {
        $hasWinGet = $null -ne (Get-Command winget -ErrorAction SilentlyContinue)
        $sync.WinGetStatus.Text = if ($hasWinGet) { "Yes" } else { "No" }
        $sync.WinGetStatus.Foreground = if ($hasWinGet) { "#FF107C10" } else { "#FFD13438" }
    }

    if ($sync.LogFilePath) {
        $sync.LogFilePath.Text = $sync.logFile
    }

    if ($sync.SystemComputerName) {
        $sync.SystemComputerName.Text = $env:COMPUTERNAME
    }

    Set-WDCAStatus "WDCA initialized and ready"

    # Initialize async operations support
    Initialize-RunspacePool
    $global:ActiveOperations = @{}
    $global:UIStateStack = @()

    # Setup cleanup on window close
    $sync.Form.Add_Closing({
            try {
                Write-Logger "Application closing - cleaning up async operations" "INFO"
                Stop-AllAsyncOperations
                Close-RunspacePool
            }
            catch {
                Write-Logger "Error during window close cleanup: $($_.Exception.Message)" "ERROR"
            }
        })

    # FIXED: Safer exception handler setup
    try {
        $sync.Form.Add_SourceInitialized({
                try {
                    # Check if Dispatcher exists before adding handler
                    if ($sync.Form.Dispatcher -and $sync.Form.Dispatcher.UnhandledException) {
                        $sync.Form.Dispatcher.UnhandledException.Add({
                                param($sender, $e)
                                Write-Logger "Unhandled exception: $($e.Exception.Message)" "ERROR"
                                Stop-AllAsyncOperations
                                $e.Handled = $true
                            })
                    }
                }
                catch {
                    Write-Logger "Could not set up exception handler: $($_.Exception.Message)" "WARNING"
                }
            })
    }
    catch {
        Write-Logger "Error setting up source initialized handler: $($_.Exception.Message)" "WARNING"
    }

    # Set initial content
    Show-Content "Applications"

    # Final validation before showing dialog
    if ($sync.Form -eq $null) {
        throw "Form is null - cannot display window"
    }

    Write-Logger "Showing main window..." "INFO"

    # Show the window with error handling
    try {
        $sync.Form.ShowDialog() | Out-Null
    }
    catch [System.InvalidOperationException] {
        Write-Logger "InvalidOperationException during ShowDialog: $($_.Exception.Message)" "ERROR"
        # Try alternative approach
        try {
            $sync.Form.Show()
            # Keep application alive
            [System.Windows.Threading.Dispatcher]::Run()
        }
        catch {
            Write-Logger "Alternative show method also failed: $($_.Exception.Message)" "ERROR"
            throw
        }
    }
    catch {
        Write-Logger "Unexpected error during ShowDialog: $($_.Exception.Message)" "ERROR"
        throw
    }
}
catch {
    Write-Logger "Critical error in main execution: $($_.Exception.Message)" "ERROR"
    Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Red

    # Try more detailed error analysis
    if ($_.Exception.InnerException) {
        Write-Host "Inner exception: $($_.Exception.InnerException.Message)" -ForegroundColor Red
    }

    # Form-specific diagnosis
    if ($global:sync.Form) {
        Write-Host "Form status: Exists" -ForegroundColor Yellow
        try {
            Write-Host "Form type: $($global:sync.Form.GetType().FullName)" -ForegroundColor Yellow
            Write-Host "Form IsLoaded: $($global:sync.Form.IsLoaded)" -ForegroundColor Yellow
        }
        catch {
            Write-Host "Cannot get form details: $($_.Exception.Message)" -ForegroundColor Red
        }

        try {
            $sync.Form.Close()
        }
        catch {
            Write-Logger "Error closing form: $($_.Exception.Message)" "ERROR"
        }
    }
    else {
        Write-Host "Form status: NULL" -ForegroundColor Red
    }

    Read-Host "Press Enter to exit"
}
finally {
    # Cleanup async operations
    try {
        Write-Logger "Starting final cleanup..." "INFO"
        Stop-AllAsyncOperations
        Close-RunspacePool
        Write-Logger "Async operations cleaned up" "INFO"
    }
    catch {
        Write-Logger "Error during async cleanup: $($_.Exception.Message)" "ERROR"
    }

    # Clear sync hashtable
    if ($sync) {
        try {
            $sync.Clear()
            Write-Logger "Sync hashtable cleared" "INFO"
        }
        catch {
            Write-Logger "Error clearing sync hashtable: $($_.Exception.Message)" "ERROR"
        }
    }

    Write-Logger "WDCA execution completed" "INFO"
}